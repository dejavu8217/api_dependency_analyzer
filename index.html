<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API ì˜ì¡´ì„± ì‹œê°í™” & ë¦¬ìŠ¤í¬ ë¶„ì„ê¸° (ê°œì„ v0.8)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow: hidden;
        }

        /* Layout */
        #app {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        #left-panel {
            width: 300px;
            background: #141414;
            border-right: 1px solid #2a2a4a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        #main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #right-panel {
            width: 340px;
            background: #141414;
            border-left: 1px solid #2a2a4a;
            padding: 20px;
            overflow-y: auto;
        }

        /* Header */
        #header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 16px 24px;
            border-bottom: 1px solid #2a2a4a;
            display: flex;
            align-items: center;
            gap: 16px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.5);
        }

        #header h1 {
            font-size: 20px;
            font-weight: 600;
            color: #ffffff;
            flex: 1;
        }

        /* File Upload */
        .upload-section {
            padding: 20px;
            border-bottom: 1px solid #2a2a4a;
        }

        .upload-btn {
            display: block;
            width: 100%;
            padding: 10px;
            background: #EA4D08;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
            transition: all 0.3s;
        }

        .upload-btn:hover {
            background: #d44207;
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(234, 77, 8, 0.3);
        }

        input[type="file"] {
            display: none;
        }

        /* View Switcher */
        .view-switcher {
            display: flex;
            gap: 8px;
            padding: 12px 24px;
            background: #16213e;
            border-bottom: 1px solid #2a2a4a;
        }

        .view-btn {
            padding: 8px 16px;
            background: #2a2a4a;
            color: #8892b0;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .view-btn.active {
            background: #EA4D08;
            color: white;
        }

        .view-btn:hover:not(.active) {
            background: #3a3a5a;
            color: #64ffda;
        }

        /* Search */
        .search-section {
            padding: 16px;
            border-bottom: 1px solid #2a2a4a;
        }

        .search-input {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #2a2a4a;
            border-radius: 6px;
            color: white;
            font-size: 14px;
        }

        .search-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
        }

        /* Stats */
        .stats-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            padding: 16px;
            border-bottom: 1px solid #2a2a4a;
        }

        .stat-card {
            background: #1a1a1a;
            border: 1px solid #2a2a4a;
            border-radius: 6px;
            padding: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #64ffda;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #8892b0;
            text-transform: uppercase;
            margin-top: 2px;
        }

        /* Groups List */
        .groups-section {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .section-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            color: #8892b0;
            margin-bottom: 12px;
            letter-spacing: 0.5px;
        }

        .group-item {
            padding: 10px;
            margin-bottom: 4px;
            background: #1a1a1a;
            border: 1px solid #2a2a4a;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .group-item:hover {
            border-color: #667eea;
            transform: translateX(3px);
        }

        .group-item.active {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2) 0%, rgba(118, 75, 162, 0.2) 100%);
            border-color: #64ffda;
        }

        .group-name {
            font-size: 14px;
            color: #e0e0e0;
            font-weight: 500;
        }

        .group-count {
            font-size: 12px;
            color: #8892b0;
            background: #2a2a4a;
            padding: 2px 8px;
            border-radius: 12px;
        }

        .group-item.active .group-count {
            background: rgba(100, 255, 218, 0.2);
            color: #64ffda;
        }

        /* Canvas */
        #canvas {
            flex: 1;
            background: radial-gradient(circle at center, #1a1a1a 0%, #0a0a0a 100%);
            position: relative;
            overflow: hidden;
        }

        #graph-svg {
            width: 100%;
            height: 100%;
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            background: rgba(26, 26, 46, 0.9);
            border: 1px solid #2a2a4a;
            border-radius: 4px;
            color: #8892b0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: #2a2a4a;
            color: #64ffda;
            border-color: #64ffda;
        }

        /* Right Panel */
        .metric-card {
            background: #1a1a1a;
            border: 1px solid #2a2a4a;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .metric-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            color: #8892b0;
            margin-bottom: 12px;
            letter-spacing: 0.5px;
        }

        .metric-value {
            font-size: 24px;
            font-weight: 600;
            color: #64ffda;
            margin-bottom: 8px;
        }

        .metric-label {
            font-size: 14px;
            color: #8892b0;
            margin-bottom: 4px;
            font-weight: 500;
        }

        .metric-detail {
            font-size: 14px;
            color: #e0e0e0;
            line-height: 1.6;
            margin-top: 8px;
        }

        .risk-gauge {
            height: 8px;
            background: #2a2a4a;
            border-radius: 4px;
            margin: 12px 0;
            position: relative;
            overflow: hidden;
        }

        .risk-gauge-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #f07178);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .dependency-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .dependency-item {
            padding: 8px;
            background: #1a1a1a;
            border-left: 3px solid #667eea;
            border-radius: 0 4px 4px 0;
            margin-bottom: 6px;
            font-size: 13px;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.2s;
        }

        .dependency-item:hover {
            background: rgba(102, 126, 234, 0.1);
            transform: translateX(2px);
        }

        .dependency-item.incoming {
            border-left-color: #EA4D08;
        }

        .dependency-item.outgoing {
            border-left-color: #0c8ce9;
        }

        .dependency-item.circular {
            border-left-color: #c792ea;
        }

        .dependency-type {
            font-size: 11px;
            color: #8892b0;
            text-transform: uppercase;
            margin-top: 4px;
        }

        /* Matrix View */
        #matrix-container {
            display: none;
            padding: 20px;
            overflow: auto;
            height: 100%;
        }

        .matrix-cell {
            cursor: pointer;
            transition: all 0.2s;
        }

        .matrix-cell:hover {
            filter: brightness(1.3);
        }

        .matrix-label {
            font-size: 11px;
            fill: #e0e0e0;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            padding: 10px;
            background: rgba(26, 26, 46, 0.98);
            border: 1px solid #667eea;
            border-radius: 6px;
            color: white;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 300px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .tooltip.show {
            opacity: 1;
        }

        .tooltip h4 {
            color: #64ffda;
            margin-bottom: 6px;
            font-size: 14px;
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }

        .tooltip-label {
            color: #8892b0;
        }

        .tooltip-value {
            color: #e0e0e0;
            font-weight: 500;
        }

        /* Cycles Panel */
        .cycles-section {
            margin-top: 20px;
            padding: 16px;
        }

        .cycle-item {
            padding: 10px;
            background: #1a1a1a;
            border-left: 3px solid #c792ea;
            border-radius: 0 6px 6px 0;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cycle-item:hover {
            background: rgba(199, 146, 234, 0.1);
            transform: translateX(4px);
        }

        .cycle-nodes {
            font-size: 12px;
            color: #8892b0;
            margin-top: 4px;
        }

        /* Legend */
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(26, 26, 46, 0.95);
            border: 1px solid #2a2a4a;
            border-radius: 8px;
            padding: 12px;
            font-size: 12px;
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            flex-shrink: 0;
        }

        /* Loading */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #2a2a4a;
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Node styles for graph */
        .node {
            cursor: pointer;
        }

        .node-label {
            font-size: 11px;
            pointer-events: none;
            fill: #e0e0e0;
            text-anchor: middle;
        }

        .link {
            fill: none;
            stroke-opacity: 0.4;
            transition: all 0.3s;
        }

        .link.highlighted {
            stroke-opacity: 1;
            stroke-width: 3;
            stroke: #64ffda !important;
        }

        .node.highlighted circle {
            stroke: #64ffda;
            stroke-width: 3;
            filter: brightness(1.3);
        }

        .node.dimmed {
            opacity: 0.2;
        }

        .link.dimmed {
            opacity: 0.1;
        }

        .group-node {
            fill-opacity: 0.15;
            stroke-width: 2;
            cursor: pointer;
            transition: all 0.3s;
        }
        .group-node-g.dimmed {
             opacity: 0.3;
        }

        .group-node-g.highlighted .group-node {
            stroke-width: 4;
            stroke: #64ffda;
            fill-opacity: 0.3;
        }


        .group-node:hover {
            fill-opacity: 0.25;
            stroke-width: 3;
        }

        .group-node.focused {
            fill-opacity: 0.3;
            stroke-width: 3;
        }

        .group-label {
            font-size: 14px;
            font-weight: 600;
            fill: #ffffff;
            text-anchor: middle;
            pointer-events: none;
            text-shadow: 0 0 4px rgba(0,0,0,0.8);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            color: #8892b0;
            padding: 20px;
            font-size: 14px;
        }

        .empty-state-icon {
            font-size: 2rem;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #0f0f23;
        }

        ::-webkit-scrollbar-thumb {
            background: #2a2a4a;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #3a3a5a;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Left Panel -->
        <div id="left-panel">
            <div class="upload-section">
                <label for="openapi-upload">
                    <div class="upload-btn">ğŸ“ OpenAPI ì—…ë¡œë“œ</div>
                </label>
                <input type="file" id="openapi-upload" accept=".json">
                
                <label for="metrics-upload">
                    <div class="upload-btn">ğŸ“Š ë©”íŠ¸ë¦­ ì—…ë¡œë“œ</div>
                </label>
                <input type="file" id="metrics-upload" accept=".json">
                
                <button class="upload-btn" onclick="loadSampleData()" style="background: linear-gradient(135deg, #f07178 0%, #c792ea 100%);">
                    ğŸ¯ ìƒ˜í”Œ ë°ì´í„° ë¡œë“œ
                </button>
            </div>

            <div class="search-section">
                <input type="text" class="search-input" placeholder="API ê²€ìƒ‰..." id="search-input">
            </div>

            <div class="stats-container">
                <div class="stat-card">
                    <div class="stat-value" id="stat-groups">0</div>
                    <div class="stat-label">ê·¸ë£¹</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-apis">0</div>
                    <div class="stat-label">API</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-deps">0</div>
                    <div class="stat-label">ì˜ì¡´ì„±</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-cycles">0</div>
                    <div class="stat-label">ìˆœí™˜</div>
                </div>
            </div>

            <div class="groups-section">
                <div class="section-title">API ê·¸ë£¹</div>
                <div id="groups-list"></div>
            </div>

            <div class="cycles-section" id="cycles-section" style="display: none;">
                <div class="section-title">ìˆœí™˜ ì˜ì¡´ì„±</div>
                <div id="cycles-list"></div>
            </div>
        </div>

        <!-- Main Content -->
        <div id="main-content">
            <div id="header">
                <h1>ğŸ” API ì˜ì¡´ì„± ë¶„ì„ê¸°</h1>
                <span id="status" style="color: #8892b0; font-size: 14px;">íŒŒì¼ì„ ì—…ë¡œë“œí•˜ê±°ë‚˜ ìƒ˜í”Œ ë°ì´í„°ë¥¼ ë¡œë“œí•˜ì„¸ìš”</span>
            </div>

            <div class="view-switcher">
                <button class="view-btn active" data-view="group">ê·¸ë£¹ë·°</button>
                <button class="view-btn" data-view="detail">ìƒì„¸ë·°</button>
                <button class="view-btn" data-view="matrix">ë§¤íŠ¸ë¦­ìŠ¤</button>
            </div>

            <div id="canvas">
                <svg id="graph-svg"></svg>
                <div id="matrix-container"></div>
                
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="zoomIn()">+</button>
                    <button class="zoom-btn" onclick="zoomOut()">âˆ’</button>
                    <button class="zoom-btn" onclick="resetZoom()">âŸ²</button>
                    <button class="zoom-btn" onclick="fitToScreen()">âŠ¡</button>
                </div>
                
                <div id="legend" class="legend">
                    <!-- Legend will be dynamically populated here -->
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div id="right-panel">
            <div id="node-info" style="display: none;">
                <div class="metric-card">
                    <div class="metric-title">ì„ íƒëœ í•­ëª©</div>
                    <h3 id="selected-name" style="color: #64ffda; margin-bottom: 8px;">-</h3>
                    <div id="selected-details" class="metric-detail"></div>
                </div>

                <div class="metric-card">
                    <div class="metric-title">ìœ„í—˜ë„ í‰ê°€</div>
                    <div class="metric-value" id="risk-score">-</div>
                    <div class="risk-gauge">
                        <div class="risk-gauge-fill" id="risk-gauge"></div>
                    </div>
                    <div class="metric-detail" id="risk-detail"></div>
                </div>

                <div class="metric-card">
                    <div class="metric-title">ì˜ì¡´ì„± ë¶„ì„</div>
                    <div class="metric-label">ë“¤ì–´ì˜¤ëŠ” ì˜ì¡´ì„± (IN)</div>
                    <div class="dependency-list" id="in-dependencies"></div>
                    <div class="metric-label" style="margin-top: 12px;">ë‚˜ê°€ëŠ” ì˜ì¡´ì„± (OUT)</div>
                    <div class="dependency-list" id="out-dependencies"></div>
                </div>

                <div class="metric-card">
                    <div class="metric-title">ì˜í–¥ë„</div>
                    <div class="metric-detail" id="impact-detail"></div>
                </div>
            </div>

            <div id="default-info">
                <div class="metric-card">
                    <div class="metric-title">ì‹œì‘í•˜ê¸°</div>
                    <div class="metric-detail">
                        1. OpenAPI JSON íŒŒì¼ì„ ì—…ë¡œë“œí•˜ê±°ë‚˜<br>
                        2. ìƒ˜í”Œ ë°ì´í„°ë¥¼ ë¡œë“œí•˜ì„¸ìš”<br>
                        3. ë…¸ë“œë¥¼ í´ë¦­í•˜ì—¬ ìƒì„¸ ì •ë³´ë¥¼ í™•ì¸í•˜ì„¸ìš”<br><br>
                        <strong>ë‹¨ì¶•í‚¤:</strong><br>
                        â€¢ ESC: í¬ì»¤ìŠ¤ í•´ì œ<br>
                        â€¢ ë¹ˆ ê³µê°„ í´ë¦­: ì„ íƒ í•´ì œ
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Global state
        let nodes = [];
        let links = [];
        let groups = new Map();
        let metrics = new Map();
        let currentView = 'group';
        let simulation = null;
        let svg = null;
        let g = null;
        let focusedNodeId = null;
        let focusedGroupId = null;
        let cycles = [];
        let zoom = null;

        // Group colors
        const groupColors = {
            'ì¸ì¦Â·ë³´ì•ˆ': '#c792ea',
            'ì‚¬ìš©ìÂ·ë©¤ë²„': '#64ffda',
            'ìƒí’ˆÂ·ì œí’ˆ': '#ffcb6b',
            'ì£¼ë¬¸Â·ì¥ë°”êµ¬ë‹ˆ': '#f07178',
            'êµ¬ë…Â·ê²°ì œ': '#82aaff',
            'ì„¤ì •Â·ê´€ë¦¬ì': '#ff5370',
            'ë¦¬í¬íŠ¸Â·ëŒ€ì‹œë³´ë“œ': '#c3e88d',
            'ì´ë©”ì¼Â·ìº í˜ì¸': '#ffc777',
            'í†µí•©Â·ì—°ë™': '#89ddff',
            'íŒ€Â·ì¡°ì§': '#b2ccd6',
            'general': '#8892b0'
        };

        // Group mapping rules
        const groupMappings = {
            'auth': 'ì¸ì¦Â·ë³´ì•ˆ',
            'authentication': 'ì¸ì¦Â·ë³´ì•ˆ',
            'login': 'ì¸ì¦Â·ë³´ì•ˆ',
            'logout': 'ì¸ì¦Â·ë³´ì•ˆ',
            'user': 'ì‚¬ìš©ìÂ·ë©¤ë²„',
            'users': 'ì‚¬ìš©ìÂ·ë©¤ë²„',
            'member': 'ì‚¬ìš©ìÂ·ë©¤ë²„',
            'profile': 'ì‚¬ìš©ìÂ·ë©¤ë²„',
            'product': 'ìƒí’ˆÂ·ì œí’ˆ',
            'products': 'ìƒí’ˆÂ·ì œí’ˆ',
            'item': 'ìƒí’ˆÂ·ì œí’ˆ',
            'catalog': 'ìƒí’ˆÂ·ì œí’ˆ',
            'order': 'ì£¼ë¬¸Â·ì¥ë°”êµ¬ë‹ˆ',
            'orders': 'ì£¼ë¬¸Â·ì¥ë°”êµ¬ë‹ˆ',
            'cart': 'ì£¼ë¬¸Â·ì¥ë°”êµ¬ë‹ˆ',
            'checkout': 'ì£¼ë¬¸Â·ì¥ë°”êµ¬ë‹ˆ',
            'payment': 'êµ¬ë…Â·ê²°ì œ',
            'payments': 'êµ¬ë…Â·ê²°ì œ',
            'billing': 'êµ¬ë…Â·ê²°ì œ',
            'subscription': 'êµ¬ë…Â·ê²°ì œ',
            'admin': 'ì„¤ì •Â·ê´€ë¦¬ì',
            'settings': 'ì„¤ì •Â·ê´€ë¦¬ì',
            'config': 'ì„¤ì •Â·ê´€ë¦¬ì',
            'report': 'ë¦¬í¬íŠ¸Â·ëŒ€ì‹œë³´ë“œ',
            'reports': 'ë¦¬í¬íŠ¸Â·ëŒ€ì‹œë³´ë“œ',
            'dashboard': 'ë¦¬í¬íŠ¸Â·ëŒ€ì‹œë³´ë“œ',
            'analytics': 'ë¦¬í¬íŠ¸Â·ëŒ€ì‹œë³´ë“œ',
            'email': 'ì´ë©”ì¼Â·ìº í˜ì¸',
            'campaign': 'ì´ë©”ì¼Â·ìº í˜ì¸',
            'notification': 'ì´ë©”ì¼Â·ìº í˜ì¸',
            'integration': 'í†µí•©Â·ì—°ë™',
            'webhook': 'í†µí•©Â·ì—°ë™',
            'api': 'í†µí•©Â·ì—°ë™',
            'team': 'íŒ€Â·ì¡°ì§',
            'organization': 'íŒ€Â·ì¡°ì§',
            'workspace': 'íŒ€Â·ì¡°ì§'
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', init);

        function init() {
            setupEventListeners();
            initializeGraph();
        }

        function setupEventListeners() {
            document.getElementById('openapi-upload').addEventListener('change', handleOpenAPIUpload);
            document.getElementById('metrics-upload').addEventListener('change', handleMetricsUpload);

            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.addEventListener('click', (e) => switchView(e.target.dataset.view));
            });

            document.getElementById('search-input').addEventListener('input', handleSearch);

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    clearFocus();
                }
            });
        }

        function initializeGraph() {
            const canvas = document.getElementById('canvas');
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;

            svg = d3.select('#graph-svg');

            const defs = svg.append('defs');
            
            const arrowTypes = [
                { id: 'arrow-normal', color: '#8892b0' },
                { id: 'arrow-crud', color: '#64ffda' },
                { id: 'arrow-auth-required', color: '#c792ea' },
                { id: 'arrow-workflow', color: '#f07178' },
                { id: 'arrow-reference', color: '#f78c6c' },
                { id: 'arrow-read-modify', color: '#82aaff' },
                { id: 'arrow-list-detail', color: '#ffcb6b' },
                { id: 'arrow-parent-child', color: '#c3e88d' },
                { id: 'arrow-user-action', color: '#89ddff' },
                { id: 'arrow-admin-control', color: '#ff5370' },
                { id: 'arrow-data-source', color: '#b2ccd6' },
                { id: 'arrow-detail-incoming', color: '#EA4D08' },
                { id: 'arrow-detail-outgoing', color: '#0c8ce9' },
                { id: 'arrow-group-incoming', color: '#EA4D08' },
                { id: 'arrow-group-outgoing', color: '#0c8ce9' }
            ];
            
            arrowTypes.forEach(arrow => {
                defs.append('marker')
                    .attr('id', arrow.id)
                    .attr('viewBox', '0 -5 10 10')
                    .attr('refX', currentView === 'group' ? 18 : 25)
                    .attr('refY', 0)
                    .attr('markerWidth', 5)
                    .attr('markerHeight', 5)
                    .attr('orient', 'auto')
                    .attr('markerUnits', 'strokeWidth')
                    .append('path')
                    .attr('d', 'M0,-5L10,0L0,5')
                    .attr('fill', arrow.color)
                    .style('opacity', 0.9);
            });

            g = svg.append('g');

            zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => g.attr('transform', event.transform));

            svg.call(zoom);
            svg.on('click', (event) => {
                if (event.target === svg.node()) clearFocus();
            });
        }
        
        async function loadFile(file, type) {
            if (!file) return null;
            updateStatus(`â³ ${type} íŒŒì¼ ë¡œë”© ì¤‘...`);
            try {
                const text = await file.text();
                return JSON.parse(text);
            } catch (error) {
                updateStatus(`âŒ ${type} íŒŒì‹± ì‹¤íŒ¨: ${error.message}`);
                alert(`${type} íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n${error.message}`);
                return null;
            }
        }

        async function handleOpenAPIUpload(event) {
            const data = await loadFile(event.target.files[0], 'OpenAPI');
            if (data) {
                if (!data.paths && !data.swagger && !data.openapi) {
                    alert('ìœ íš¨í•œ OpenAPI/Swagger íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤.');
                    return;
                }
                parseOpenAPI(data);
                updateStatus(`âœ… OpenAPI ë¡œë“œ ì™„ë£Œ: ${nodes.length}ê°œ API, ${links.length}ê°œ ì˜ì¡´ì„±`);
                renderGraph();
            }
        }

        async function handleMetricsUpload(event) {
            const data = await loadFile(event.target.files[0], 'ë©”íŠ¸ë¦­');
            if (data) {
                if (!Array.isArray(data) && typeof data !== 'object') {
                    alert('ìœ íš¨í•œ ë©”íŠ¸ë¦­ íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤.');
                    return;
                }
                parseMetrics(data);
                updateStatus(`âœ… ë©”íŠ¸ë¦­ ë¡œë“œ ì™„ë£Œ: ${metrics.size}ê°œ API ë©”íŠ¸ë¦­`);
                if (nodes.length > 0) renderGraph();
            }
        }

        function parseOpenAPI(data) {
            nodes = [];
            links = [];
            groups.clear();
            const nodeMap = new Map();

            const paths = data.paths || {};
            if (Object.keys(paths).length === 0) {
                updateStatus('âš ï¸ API ê²½ë¡œê°€ ì—†ìŠµë‹ˆë‹¤');
                return;
            }

            Object.entries(paths).forEach(([path, methods]) => {
                if (!methods || typeof methods !== 'object') return;
                
                Object.entries(methods).forEach(([method, spec]) => {
                    if (!['get', 'post', 'put', 'patch', 'delete'].includes(method.toLowerCase()) || typeof spec !== 'object') return;

                    const apiId = `${method.toUpperCase()}_${path}`;
                    const group = normalizeGroup(extractGroup(path, spec));

                    const node = {
                        id: apiId,
                        apiName: spec.summary || spec.operationId || apiId,
                        method: method.toUpperCase(),
                        path: path,
                        group: group,
                        description: spec.description || '',
                        tags: spec.tags || []
                    };
                    nodes.push(node);
                    nodeMap.set(apiId, node);

                    if (!groups.has(group)) {
                        groups.set(group, { name: group, apis: [], color: groupColors[group] || '#8892b0' });
                    }
                    groups.get(group).apis.push(node);
                });
            });

            analyzeDependencies();
            detectCycles();
            updateAllUI();
        }
        
        function updateAllUI() {
            updateStats();
            updateGroupsList();
            updateCyclesList();
            updateLegend();
        }

        function extractGroup(path, spec) {
            if (spec.tags && spec.tags.length > 0) return spec.tags[0];
            const pathParts = path.split('/').filter(p => p && !p.startsWith('{'));
            return pathParts.length > 0 ? pathParts[0] : 'general';
        }

        function normalizeGroup(rawGroup) {
            const lower = rawGroup.toLowerCase();
            for (const [key, normalized] of Object.entries(groupMappings)) {
                if (lower.includes(key)) return normalized;
            }
            return rawGroup;
        }

        function analyzeDependencies() {
            const tempLinks = [];
            nodes.forEach(source => {
                nodes.forEach(target => {
                    if (source.id === target.id) return;

                    const sourceResource = source.path.split('/')[1] || '';
                    const targetResource = target.path.split('/')[1] || '';
                    
                    if (sourceResource === targetResource) {
                        if (source.method === 'POST' && ['GET', 'PUT', 'DELETE'].includes(target.method)) {
                             tempLinks.push({ source: source.id, target: target.id, type: 'crud', weight: 3, description: 'Create â†’ R/U/D' });
                        }
                        if (source.method === 'GET' && ['PUT', 'DELETE'].includes(target.method)) {
                            tempLinks.push({ source: source.id, target: target.id, type: 'read-modify', weight: 2, description: 'Read â†’ Modify' });
                        }
                    }
                    
                    if (source.group !== target.group) {
                         if (source.group === 'ì£¼ë¬¸Â·ì¥ë°”êµ¬ë‹ˆ' && target.group === 'ìƒí’ˆÂ·ì œí’ˆ') {
                            tempLinks.push({ source: source.id, target: target.id, type: 'reference', weight: 3, description: 'Order â†’ Product' });
                        }
                        if (source.group === 'ì£¼ë¬¸Â·ì¥ë°”êµ¬ë‹ˆ' && target.group === 'êµ¬ë…Â·ê²°ì œ' && source.method === 'POST') {
                            tempLinks.push({ source: source.id, target: target.id, type: 'workflow', weight: 4, description: 'Order â†’ Payment' });
                        }
                    }

                    if (target.path.startsWith(source.path.replace(/\{[^}]+\}/, '')) && source.path.length < target.path.length) {
                        tempLinks.push({ source: source.id, target: target.id, type: 'parent-child', weight: 2, description: 'Parent â†’ Child' });
                    }
                });
            });

            const uniqueLinks = new Map();
            tempLinks.forEach(link => {
                const key = `${link.source}->${link.target}`;
                if (!uniqueLinks.has(key) || uniqueLinks.get(key).weight < link.weight) {
                    uniqueLinks.set(key, link);
                }
            });
            links = Array.from(uniqueLinks.values());
        }

        function parseMetrics(data) {
            metrics.clear();
            const metricData = Array.isArray(data) ? data : Object.entries(data).map(([key, value]) => ({ id: key, ...value }));
            metricData.forEach(m => {
                const key = m.id || `${m.method}_${m.path}`;
                metrics.set(key, {
                    calls: m.calls || m.requests || 0,
                    p95: m.p95 || m.latency || 0,
                    errorRate: m.errorRate || m.errors || 0
                });
            });
        }

        function detectCycles() {
            cycles = [];
            const index = new Map(), lowlink = new Map(), stack = [], onStack = new Set();
            let idx = 0;

            const strongconnect = (v) => {
                index.set(v, idx); lowlink.set(v, idx++);
                stack.push(v); onStack.add(v);

                const successors = links.filter(l => l.source === v).map(l => l.target);
                successors.forEach(w => {
                    if (!index.has(w)) {
                        strongconnect(w);
                        lowlink.set(v, Math.min(lowlink.get(v), lowlink.get(w)));
                    } else if (onStack.has(w)) {
                        lowlink.set(v, Math.min(lowlink.get(v), index.get(w)));
                    }
                });

                if (lowlink.get(v) === index.get(v)) {
                    const component = [];
                    let w;
                    do {
                        w = stack.pop(); onStack.delete(w);
                        component.push(w);
                    } while (w !== v);
                    if (component.length > 1) cycles.push(component);
                }
            };

            nodes.forEach(node => { if (!index.has(node.id)) strongconnect(node.id); });
        }
        
        function updateLegend() {
            const legendContainer = document.getElementById('legend');
            legendContainer.innerHTML = '';
            if (groups.size === 0) return;

            Array.from(groups.values()).sort((a,b) => a.name.localeCompare(b.name)).forEach(group => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `<div class="legend-color" style="background: ${group.color};"></div><span>${group.name}</span>`;
                legendContainer.appendChild(item);
            });
        }

        function updateGroupsList() {
            const listEl = document.getElementById('groups-list');
            listEl.innerHTML = '';

            if (groups.size === 0) {
                listEl.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ğŸ“‚</div>ë°ì´í„°ë¥¼ ë¡œë“œí•˜ì„¸ìš”</div>';
                return;
            }

            Array.from(groups.values()).sort((a,b) => a.name.localeCompare(b.name)).forEach(group => {
                const item = document.createElement('div');
                item.className = 'group-item';
                item.classList.toggle('active', focusedGroupId === group.name);
                item.innerHTML = `<span class="group-name">${group.name}</span><span class="group-count">${group.apis.length}</span>`;
                item.addEventListener('click', () => focusGroup(group.name));
                listEl.appendChild(item);
            });
        }

        function updateCyclesList() {
            const section = document.getElementById('cycles-section');
            const listEl = document.getElementById('cycles-list');
            section.style.display = cycles.length > 0 ? 'block' : 'none';
            if (cycles.length === 0) return;

            listEl.innerHTML = '';
            cycles.forEach((cycle, idx) => {
                const item = document.createElement('div');
                item.className = 'cycle-item';
                item.innerHTML = `<div>ìˆœí™˜ ì˜ì¡´ì„± #${idx + 1}</div><div class="cycle-nodes">${cycle.slice(0, 3).join(' â†’ ')}${cycle.length > 3 ? ' ...' : ''}</div>`;
                item.addEventListener('click', () => focusCycle(cycle));
                listEl.appendChild(item);
            });
        }

        function renderGraph() {
            const isMatrix = currentView === 'matrix';
            document.getElementById('graph-svg').style.display = isMatrix ? 'none' : 'block';
            document.getElementById('matrix-container').style.display = isMatrix ? 'block' : 'none';

            g.selectAll('*').remove();
            
            const canvas = document.getElementById('canvas');
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            svg.attr('width', width).attr('height', height);

            if (isMatrix) renderMatrix();
            else if (currentView === 'group') renderGroupView(width, height);
            else renderDetailView(width, height);
        }

        function renderGroupView(width, height) {
            const groupNodes = Array.from(groups.values()).map(g => ({ ...g, id: g.name, radius: Math.sqrt(g.apis.length) * 20 + 30 }));
            const groupLinkMap = new Map();
            links.forEach(link => {
                const sourceNode = nodes.find(n => n.id === link.source);
                const targetNode = nodes.find(n => n.id === link.target);
                if (sourceNode && targetNode && sourceNode.group !== targetNode.group) {
                    const key = `${sourceNode.group}->${targetNode.group}`;
                    if (!groupLinkMap.has(key)) {
                        groupLinkMap.set(key, { source: sourceNode.group, target: targetNode.group, count: 0, weight: 0 });
                    }
                    const groupLink = groupLinkMap.get(key);
                    groupLink.count++;
                    groupLink.weight += link.weight || 1;
                }
            });
            const groupLinks = Array.from(groupLinkMap.values());

            simulation = d3.forceSimulation(groupNodes)
                .force('link', d3.forceLink(groupLinks).id(d => d.id).distance(250))
                .force('charge', d3.forceManyBody().strength(-1000))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => d.radius + 20));

            const link = g.append('g').selectAll('line')
                .data(groupLinks)
                .enter().append('line')
                .attr('class', 'link')
                .attr('stroke', '#666')
                .attr('stroke-width', d => Math.max(1, Math.log(d.count + 1)))
                .attr('marker-end', 'url(#arrow-normal)');

            const node = g.append('g').selectAll('g')
                .data(groupNodes)
                .enter().append('g')
                .attr('class', 'group-node-g')
                .call(drag(simulation))
                .on('click', (event, d) => { event.stopPropagation(); focusGroup(d.name); })
                .on('mouseover', (event, d) => showGroupTooltip(event, d))
                .on('mouseout', hideTooltip);

            node.append('circle').attr('class', 'group-node').attr('r', d => d.radius).attr('fill', d => d.color).attr('stroke', d => d.color);
            node.append('text').attr('class', 'group-label').attr('dy', -5).text(d => d.name);
            node.append('text').attr('class', 'node-label').attr('dy', 10).text(d => `${d.apis.length} APIs`);
            
            simulation.on('tick', () => {
                link.attr('x1', d => d.source.x).attr('y1', d => d.source.y).attr('x2', d => d.target.x).attr('y2', d => d.target.y);
                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });
            
            if (focusedGroupId) highlightGroupConnections(focusedGroupId, groupLinks);
        }

        function renderDetailView(width, height) {
            const simNodes = nodes.map(n => ({...n}));
            const simLinks = links.map(l => ({...l}));

            simulation = d3.forceSimulation(simNodes)
                .force('link', d3.forceLink(simLinks).id(d => d.id).distance(150))
                .force('charge', d3.forceManyBody().strength(-600))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(35));

            const link = g.append('g').selectAll('line')
                .data(simLinks).enter().append('line')
                .attr('class', 'link')
                .attr('stroke', d => groupColors[nodes.find(n => n.id === d.source)?.group] || '#666')
                .attr('stroke-width', d => Math.max(1, Math.sqrt(d.weight || 1)))
                .attr('marker-end', d => `url(#arrow-${d.type || 'normal'})`);

            const node = g.append('g').selectAll('g')
                .data(simNodes).enter().append('g')
                .attr('class', 'node')
                .call(drag(simulation))
                .on('click', (event, d) => { event.stopPropagation(); focusNode(d); })
                .on('mouseover', (event, d) => showNodeTooltip(event, d))
                .on('mouseout', hideTooltip);

            node.append('circle').attr('r', 20).attr('fill', d => groupColors[d.group] || '#8892b0').attr('stroke', '#fff').attr('stroke-width', 2);
            node.append('text').attr('class', 'node-label').attr('dy', 30).text(d => d.apiName.length > 20 ? d.apiName.substring(0, 17) + '...' : d.apiName);
            
            simulation.on('tick', () => {
                link.attr('x1', d => d.source.x).attr('y1', d => d.source.y).attr('x2', d => d.target.x).attr('y2', d => d.target.y);
                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });
            
            if (focusedNodeId) {
                const focused = nodes.find(n => n.id === focusedNodeId);
                if (focused) highlightNodeConnections(focused);
            }
        }
        
        function renderMatrix() { /* ... unchanged ... */ }

        function drag(simulation) {
            function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
            function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
            function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }
            return d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended);
        }

        function focusNode(node) {
            focusedNodeId = node.id;
            focusedGroupId = null;
            updateNodeInfo(node);
            highlightNodeConnections(node);
            updateGroupsList(); // To show active group
        }

        function focusGroup(groupName) {
            focusedGroupId = groupName;
            focusedNodeId = null;
            const group = groups.get(groupName);
            if (group) {
                updateGroupInfo(group);
                if(currentView === 'group') {
                    const groupLinks = Array.from(g.selectAll('.link').data());
                    highlightGroupConnections(groupName, groupLinks);
                }
            }
            updateGroupsList();
        }
        
        function focusCycle(cycle) { /* ... unchanged ... */ }

        function highlightNodeConnections(node) {
            const connectedNodes = new Set([node.id]);
            links.forEach(link => {
                if (link.target === node.id) connectedNodes.add(link.source);
                if (link.source === node.id) connectedNodes.add(link.target);
            });

            g.selectAll('.node').classed('dimmed', d => !connectedNodes.has(d.id));
            g.selectAll('.node').select('circle').style('stroke', d => d.id === node.id ? '#64ffda' : '#fff').style('stroke-width', d => d.id === node.id ? 3 : 2);
            
            g.selectAll('.link')
                .style('stroke', d => d.source.id === node.id ? '#0c8ce9' : (d.target.id === node.id ? '#EA4D08' : '#666'))
                .style('stroke-dasharray', d => d.source.id === node.id ? '5,5' : 'none')
                .style('stroke-opacity', d => (d.source.id === node.id || d.target.id === node.id) ? 1 : 0.1)
                .attr('marker-end', d => d.source.id === node.id ? 'url(#arrow-detail-outgoing)' : (d.target.id === node.id ? 'url(#arrow-detail-incoming)' : 'url(#arrow-normal)'));
        }

        function highlightGroupConnections(groupName, groupLinks) {
            const connectedGroups = new Set([groupName]);
            groupLinks.forEach(link => {
                if (link.source.id === groupName) connectedGroups.add(link.target.id);
                if (link.target.id === groupName) connectedGroups.add(link.source.id);
            });

            g.selectAll('.group-node-g').classed('dimmed', d => !connectedGroups.has(d.id));
            g.selectAll('.group-node-g').classed('highlighted', d => d.id === groupName);

            g.selectAll('.link')
                .style('stroke', d => d.source.id === groupName ? '#0c8ce9' : (d.target.id === groupName ? '#EA4D08' : '#666'))
                .style('stroke-dasharray', d => d.source.id === groupName ? '5,5' : 'none')
                .style('stroke-opacity', d => (d.source.id === groupName || d.target.id === groupName) ? 1 : 0.1)
                .attr('marker-end', d => d.source.id === groupName ? 'url(#arrow-group-outgoing)' : (d.target.id === groupName ? 'url(#arrow-group-incoming)' : 'url(#arrow-normal)'));
        }
        
        function clearFocus() {
            focusedNodeId = null;
            focusedGroupId = null;

            g.selectAll('.node, .group-node-g').classed('highlighted focused dimmed', false).select('circle').style('stroke', '#fff').style('stroke-width', 2);
            g.selectAll('.link').style('stroke', '#666').style('stroke-opacity', 0.6).style('stroke-dasharray', 'none').attr('marker-end', 'url(#arrow-normal)');
            
            updateGroupsList();
            document.getElementById('node-info').style.display = 'none';
            document.getElementById('default-info').style.display = 'block';
        }

        function updateNodeInfo(node) {
            document.getElementById('default-info').style.display = 'none';
            document.getElementById('node-info').style.display = 'block';
            document.getElementById('selected-name').textContent = node.apiName;
            document.getElementById('selected-details').innerHTML = `<div><strong>ë©”ì†Œë“œ:</strong> ${node.method}</div><div><strong>ê²½ë¡œ:</strong> ${node.path}</div><div><strong>ê·¸ë£¹:</strong> ${node.group}</div>`;

            const risk = calculateRiskScore(node);
            document.getElementById('risk-score').textContent = risk.score.toFixed(1);
            document.getElementById('risk-gauge').style.width = `${risk.score * 10}%`;
            document.getElementById('risk-detail').innerHTML = generateRiskExplanation(risk);

            updateDependencies(node);
            updateImpact(node);
        }

        function updateGroupInfo(group) {
            document.getElementById('default-info').style.display = 'none';
            document.getElementById('node-info').style.display = 'block';
            document.getElementById('selected-name').textContent = group.name;
            document.getElementById('selected-details').innerHTML = `<div><strong>API ìˆ˜:</strong> ${group.apis.length}</div>`;

            const avgRisk = group.apis.reduce((sum, api) => sum + calculateRiskScore(api).score, 0) / (group.apis.length || 1);
            document.getElementById('risk-score').textContent = avgRisk.toFixed(1);
            document.getElementById('risk-gauge').style.width = `${avgRisk * 10}%`;
            document.getElementById('risk-detail').innerHTML = `ì´ ê·¸ë£¹ì˜ í‰ê·  ìœ„í—˜ ì ìˆ˜ëŠ” ${avgRisk.toFixed(1)}ì ì…ë‹ˆë‹¤. ê·¸ë£¹ ë‚´ APIë“¤ì˜ ì˜ì¡´ì„± ë° ì¤‘ìš”ë„ë¥¼ ì¢…í•©í•œ ê²°ê³¼ì…ë‹ˆë‹¤.`;

            updateGroupDependencies(group);
        }
        
        function generateRiskExplanation(risk) {
            let explanation = `ì´ APIì˜ ìœ„í—˜ ì ìˆ˜ëŠ” <strong>${risk.score.toFixed(1)}ì </strong>ìœ¼ë¡œ í‰ê°€ë˜ì—ˆìŠµë‹ˆë‹¤. `;
            const factors = [];
            if (risk.factors.dep > 1.5) factors.push(`<strong>ë§ì€ ì˜ì¡´ì„±(${risk.factors.inDeps} In, ${risk.factors.outDeps} Out)</strong>`);
            if (risk.factors.group > 1.5) factors.push(`ì¤‘ìš”ë„ê°€ ë†’ì€ <strong>'${risk.factors.groupName}'</strong> ê·¸ë£¹ì— ì†í•œ ì `);
            if (risk.factors.method > 0.5) factors.push(`ë°ì´í„°ë¥¼ ë³€ê²½/ì‚­ì œí•˜ëŠ” <strong>'${risk.factors.methodName}'</strong> ë©”ì†Œë“œì¸ ì `);
            if (risk.factors.metric > 0.5) factors.push(`<strong>ë†’ì€ ì˜¤ë¥˜ìœ¨ ë˜ëŠ” ì§€ì—° ì‹œê°„</strong>ì„ ë³´ì´ëŠ” ì `);
            
            if (factors.length > 0) {
                explanation += `ì£¼ìš” ì›ì¸ì€ ${factors.join(', ')} ë“±ì…ë‹ˆë‹¤.`;
            } else if (risk.score > 5) {
                explanation += `ì—¬ëŸ¬ ë³´í†µ ìˆ˜ì¤€ì˜ ìœ„í—˜ ìš”ì†Œë“¤ì´ ë³µí•©ì ìœ¼ë¡œ ì‘ìš©í•œ ê²°ê³¼ì…ë‹ˆë‹¤.`
            } else {
                explanation += `ì´ëŠ” ë¹„êµì  ì•ˆì •ì ì¸ ìƒíƒœì„ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.`
            }
            return explanation;
        }

        function calculateRiskScore(node) {
            const factors = { dep: 0, method: 0, group: 0, metric: 0 };
            
            const inDeps = links.filter(l => l.target === node.id).length;
            const outDeps = links.filter(l => l.source === node.id).length;
            factors.inDeps = inDeps;
            factors.outDeps = outDeps;
            factors.dep = Math.min(4, Math.log1p(inDeps) * 1.5 + Math.log1p(outDeps) * 0.5);

            factors.methodName = node.method;
            if (node.method === 'DELETE') factors.method = 1.5;
            else if (['PUT', 'PATCH', 'POST'].includes(node.method)) factors.method = 1.0;

            factors.groupName = node.group;
            if (['ì¸ì¦Â·ë³´ì•ˆ'].includes(node.group)) factors.group = 2.5;
            else if (['êµ¬ë…Â·ê²°ì œ'].includes(node.group)) factors.group = 2.0;

            const metric = metrics.get(node.id);
            if (metric) {
                if (metric.errorRate > 0.05) factors.metric += 1.0;
                if (metric.p95 > 1000) factors.metric += 0.5;
                if (metric.calls > 10000) factors.metric += 0.5;
            }
            factors.metric = Math.min(2, factors.metric);
            
            const score = factors.dep + factors.method + factors.group + factors.metric;
            return { score: Math.min(10, score), factors };
        }
        
        function updateDependencies(node) {
            const inList = document.getElementById('in-dependencies');
            inList.innerHTML = '';
            links.filter(l => l.target === node.id).forEach(link => {
                const sourceNode = nodes.find(n => n.id === link.source);
                if(sourceNode) {
                    const item = document.createElement('div');
                    item.className = 'dependency-item incoming';
                    item.innerHTML = `<div>${sourceNode.apiName}</div><div class="dependency-type">${link.type}</div>`;
                    item.onclick = () => focusNode(sourceNode);
                    inList.appendChild(item);
                }
            });

            const outList = document.getElementById('out-dependencies');
            outList.innerHTML = '';
            links.filter(l => l.source === node.id).forEach(link => {
                const targetNode = nodes.find(n => n.id === link.target);
                if(targetNode) {
                    const item = document.createElement('div');
                    item.className = 'dependency-item outgoing';
                    item.innerHTML = `<div>${targetNode.apiName}</div><div class="dependency-type">${link.type}</div>`;
                    item.onclick = () => focusNode(targetNode);
                    outList.appendChild(item);
                }
            });
        }
        
        function updateGroupDependencies(group) { 
            const inGroups = new Map(), outGroups = new Map();
            group.apis.forEach(api => {
                links.forEach(link => {
                    if (link.target === api.id) {
                        const sourceNode = nodes.find(n => n.id === link.source);
                        if (sourceNode && sourceNode.group !== group.name) inGroups.set(sourceNode.group, (inGroups.get(sourceNode.group) || 0) + 1);
                    }
                    if (link.source === api.id) {
                        const targetNode = nodes.find(n => n.id === link.target);
                        if (targetNode && targetNode.group !== group.name) outGroups.set(targetNode.group, (outGroups.get(targetNode.group) || 0) + 1);
                    }
                });
            });

            const inList = document.getElementById('in-dependencies');
            inList.innerHTML = '';
            inGroups.forEach((count, groupName) => {
                const item = document.createElement('div');
                item.className = 'dependency-item incoming';
                item.innerHTML = `<div>${groupName}</div><div class="dependency-type">${count}ê°œ ì—°ê²°</div>`;
                item.onclick = () => focusGroup(groupName);
                inList.appendChild(item);
            });
            
            const outList = document.getElementById('out-dependencies');
            outList.innerHTML = '';
            outGroups.forEach((count, groupName) => {
                const item = document.createElement('div');
                item.className = 'dependency-item outgoing';
                item.innerHTML = `<div>${groupName}</div><div class="dependency-type">${count}ê°œ ì—°ê²°</div>`;
                item.onclick = () => focusGroup(groupName);
                outList.appendChild(item);
            });
        }

        function updateImpact(node) {
            const impacted = new Set();
            const toVisit = [node.id];
            const visited = new Set();
            let depth = 0;
            while (toVisit.length > 0 && depth < 3) {
                const levelSize = toVisit.length;
                for (let i = 0; i < levelSize; i++) {
                    const current = toVisit.shift();
                    if (visited.has(current)) continue;
                    visited.add(current);
                    links.forEach(link => {
                        if (link.source === current && !visited.has(link.target)) {
                            if(depth < 2) impacted.add(link.target);
                            toVisit.push(link.target);
                        }
                    });
                }
                depth++;
            }
            const directImpact = links.filter(l => l.source === node.id).length;
            document.getElementById('impact-detail').innerHTML = `
                <div>ì§ì ‘ ì˜í–¥: ${directImpact}ê°œ API</div>
                <div>ê°„ì ‘ ì˜í–¥ (2ë‹¨ê³„): ${impacted.size - directImpact}ê°œ API</div>
                <div style="margin-top: 8px; color: #8892b0;">
                    ì´ API ë³€ê²½ ì‹œ ì´ ${impacted.size}ê°œ ì´ìƒì˜ APIì— ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                </div>`;
        }
        
        function handleSearch(event) {
            const query = event.target.value.toLowerCase();
            if (!query) {
                g.selectAll('.node, .group-node-g').classed('dimmed', false);
                return;
            }
            if (currentView === 'detail') {
                 g.selectAll('.node').classed('dimmed', d => !(d.apiName.toLowerCase().includes(query) || d.path.toLowerCase().includes(query)));
            } else if (currentView === 'group') {
                 g.selectAll('.group-node-g').classed('dimmed', d => !d.name.toLowerCase().includes(query));
            }
        }

        function switchView(view) {
            currentView = view;
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.view === view));
            renderGraph();
        }

        function showMatrixDetail(source, target) { /* ... unchanged ... */ }
        function showGroupTooltip(event, d) { /* ... unchanged ... */ }
        function showNodeTooltip(event, d) { /* ... unchanged ... */ }
        function showMatrixTooltip(event, d) { /* ... unchanged ... */ }
        function hideTooltip() { document.getElementById('tooltip').classList.remove('show'); }
        function updateStatus(message) { document.getElementById('status').textContent = message; }
        function updateStats() {
            document.getElementById('stat-groups').textContent = groups.size;
            document.getElementById('stat-apis').textContent = nodes.length;
            document.getElementById('stat-deps').textContent = links.length;
            document.getElementById('stat-cycles').textContent = cycles.length;
        }

        // Zoom controls
        function zoomIn() { svg.transition().duration(300).call(zoom.scaleBy, 1.3); }
        function zoomOut() { svg.transition().duration(300).call(zoom.scaleBy, 0.7); }
        function resetZoom() { svg.transition().duration(300).call(zoom.transform, d3.zoomIdentity); }
        function fitToScreen() {
            const bounds = g.node().getBBox();
            if (bounds.width === 0 || bounds.height === 0) return;
            const width = svg.node().clientWidth, height = svg.node().clientHeight;
            const scale = 0.9 * Math.min(width / bounds.width, height / bounds.height);
            const translate = [width / 2 - scale * (bounds.x + bounds.width / 2), height / 2 - scale * (bounds.y + bounds.height / 2)];
            svg.transition().duration(300).call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
        }

        function loadSampleData() {
            const sampleOpenAPI = {
                openapi: "3.0.0", info: { title: "E-Commerce API", version: "1.0.0" },
                paths: {
                    "/auth/login": { post: { summary: "ì‚¬ìš©ì ë¡œê·¸ì¸", tags: ["auth"] } },
                    "/auth/register": { post: { summary: "íšŒì› ê°€ì…", tags: ["auth"] } },
                    "/users": { get: { summary: "ì‚¬ìš©ì ëª©ë¡", tags: ["user"] } },
                    "/users/{id}": { get: { summary: "ì‚¬ìš©ì ìƒì„¸", tags: ["user"] }, delete: { summary: "ì‚¬ìš©ì ì‚­ì œ", tags: ["user"] } },
                    "/products": { get: { summary: "ìƒí’ˆ ëª©ë¡", tags: ["product"] } },
                    "/products/{id}": { get: { summary: "ìƒí’ˆ ìƒì„¸", tags: ["product"] } },
                    "/orders": { post: { summary: "ì£¼ë¬¸ ìƒì„±", tags: ["order"] } },
                    "/orders/{id}": { get: { summary: "ì£¼ë¬¸ ìƒì„¸", tags: ["order"] } },
                    "/payments": { post: { summary: "ê²°ì œ ì²˜ë¦¬", tags: ["payment"] } },
                    "/admin/dashboard": { get: { summary: "ëŒ€ì‹œë³´ë“œ", tags: ["report"] } }
                }
            };
            const sampleMetrics = [
                { id: "GET_/users", calls: 15000, p95: 250, errorRate: 0.01 },
                { id: "DELETE_/users/{id}", calls: 50, p95: 600, errorRate: 0.05 },
                { id: "POST_/auth/login", calls: 8000, p95: 320, errorRate: 0.03 },
                { id: "POST_/orders", calls: 5000, p95: 800, errorRate: 0.04 },
                { id: "POST_/payments", calls: 4900, p95: 1200, errorRate: 0.08 },
                { id: "GET_/admin/dashboard", calls: 200, p95: 2500, errorRate: 0.02 }
            ];
            parseOpenAPI(sampleOpenAPI);
            parseMetrics(sampleMetrics);
            updateStatus('âœ… ìƒ˜í”Œ ë°ì´í„° ë¡œë“œ ì™„ë£Œ');
            renderGraph();
        }
    </script>
</body>
</html>
