<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API 의존성 시각화 & 리스크 분석기</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow: hidden;
        }

        /* Layout */
        #app {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        #left-panel {
            width: 300px;
            background: #141414;
            border-right: 1px solid #2a2a4a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        #main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #right-panel {
            width: 340px;
            background: #141414;
            border-left: 1px solid #2a2a4a;
            padding: 20px;
            overflow-y: auto;
        }

        /* Header */
        #header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 16px 24px;
            border-bottom: 1px solid #2a2a4a;
            display: flex;
            align-items: center;
            gap: 16px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.5);
        }

        #header h1 {
            font-size: 20px;
            font-weight: 600;
            color: #ffffff;
            flex: 1;
        }

        /* File Upload */
        .upload-section {
            padding: 20px;
            border-bottom: 1px solid #2a2a4a;
        }

        .upload-btn {
            display: block;
            width: 100%;
            padding: 10px;
            background: #EA4D08;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
            transition: all 0.3s;
        }

        .upload-btn:hover {
            background: #d44207;
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(234, 77, 8, 0.3);
        }

        input[type="file"] {
            display: none;
        }

        /* View Switcher */
        .view-switcher {
            display: flex;
            gap: 8px;
            padding: 12px 24px;
            background: #16213e;
            border-bottom: 1px solid #2a2a4a;
        }

        .view-btn {
            padding: 8px 16px;
            background: #2a2a4a;
            color: #8892b0;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .view-btn.active {
            background: #EA4D08;
            color: white;
        }

        .view-btn:hover:not(.active) {
            background: #3a3a5a;
            color: #64ffda;
        }

        /* Search */
        .search-section {
            padding: 16px;
            border-bottom: 1px solid #2a2a4a;
        }

        .search-input {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #2a2a4a;
            border-radius: 6px;
            color: white;
            font-size: 14px;
        }

        .search-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
        }

        /* Stats */
        .stats-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            padding: 16px;
            border-bottom: 1px solid #2a2a4a;
        }

        .stat-card {
            background: #1a1a1a;
            border: 1px solid #2a2a4a;
            border-radius: 6px;
            padding: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #64ffda;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #8892b0;
            text-transform: uppercase;
            margin-top: 2px;
        }

        /* Groups List */
        .groups-section {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            min-height: 250px;
        }

        .section-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            color: #8892b0;
            margin-bottom: 12px;
            letter-spacing: 0.5px;
        }

        .group-item {
            padding: 10px;
            margin-bottom: 4px;
            background: #1a1a1a;
            border: 1px solid #2a2a4a;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .group-item:hover {
            border-color: #667eea;
            transform: translateX(3px);
        }

        .group-item.active {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2) 0%, rgba(118, 75, 162, 0.2) 100%);
            border-color: #64ffda;
        }

        .group-name {
            font-size: 14px;
            color: #e0e0e0;
            font-weight: 500;
        }

        .group-count {
            font-size: 12px;
            color: #8892b0;
            background: #2a2a4a;
            padding: 2px 8px;
            border-radius: 12px;
        }

        .group-item.active .group-count {
            background: rgba(100, 255, 218, 0.2);
            color: #64ffda;
        }

        /* Canvas */
        #canvas {
            flex: 1;
            background: radial-gradient(circle at center, #1a1a1a 0%, #0a0a0a 100%);
            position: relative;
            overflow: hidden;
        }

        #graph-svg {
            width: 100%;
            height: 100%;
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            background: rgba(26, 26, 46, 0.9);
            border: 1px solid #2a2a4a;
            border-radius: 4px;
            color: #8892b0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: #2a2a4a;
            color: #64ffda;
            border-color: #64ffda;
        }

        /* Right Panel */
        .metric-card {
            background: #1a1a1a;
            border: 1px solid #2a2a4a;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .metric-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            color: #8892b0;
            margin-bottom: 12px;
            letter-spacing: 0.5px;
        }

        .metric-value {
            font-size: 24px;
            font-weight: 600;
            color: #64ffda;
            margin-bottom: 8px;
        }

        .metric-label {
            font-size: 14px;
            color: #8892b0;
            margin-bottom: 4px;
            font-weight: 500;
        }

        .metric-detail {
            font-size: 14px;
            color: #e0e0e0;
            line-height: 1.6;
            margin-top: 8px;
        }

        .risk-gauge {
            height: 8px;
            background: #2a2a4a;
            border-radius: 4px;
            margin: 12px 0;
            position: relative;
            overflow: hidden;
        }

        .risk-gauge-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #f07178);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .dependency-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .dependency-item {
            padding: 8px;
            background: #1a1a1a;
            border-left: 3px solid #667eea;
            border-radius: 0 4px 4px 0;
            margin-bottom: 6px;
            font-size: 13px;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.2s;
        }

        .dependency-item:hover {
            background: rgba(102, 126, 234, 0.1);
            transform: translateX(2px);
        }

        .dependency-item.incoming {
            border-left-color: #64ffda;
        }

        .dependency-item.outgoing {
            border-left-color: #f07178;
        }

        .dependency-item.circular {
            border-left-color: #c792ea;
        }

        .dependency-type {
            font-size: 11px;
            color: #8892b0;
            text-transform: uppercase;
            margin-top: 4px;
        }

        /* Matrix View */
        #matrix-container {
            display: none;
            padding: 20px;
            overflow: auto;
            height: 100%;
        }

        .matrix-cell {
            cursor: pointer;
            transition: all 0.2s;
        }

        .matrix-cell:hover {
            filter: brightness(1.3);
        }

        .matrix-label {
            font-size: 11px;
            fill: #e0e0e0;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            padding: 10px;
            background: rgba(26, 26, 46, 0.98);
            border: 1px solid #667eea;
            border-radius: 6px;
            color: white;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 300px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .tooltip.show {
            opacity: 1;
        }

        .tooltip h4 {
            color: #64ffda;
            margin-bottom: 6px;
            font-size: 14px;
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }

        .tooltip-label {
            color: #8892b0;
        }

        .tooltip-value {
            color: #e0e0e0;
            font-weight: 500;
        }

        /* Cycles Panel */
        .cycles-section {
            margin-top: 20px;
            padding: 16px;
        }

        .cycle-item {
            padding: 10px;
            background: #1a1a1a;
            border-left: 3px solid #c792ea;
            border-radius: 0 6px 6px 0;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cycle-item:hover {
            background: rgba(199, 146, 234, 0.1);
            transform: translateX(4px);
        }

        .cycle-nodes {
            font-size: 12px;
            color: #8892b0;
            margin-top: 4px;
        }

        /* Legend */
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(26, 26, 46, 0.95);
            border: 1px solid #2a2a4a;
            border-radius: 8px;
            padding: 12px;
            font-size: 12px;
            z-index: 100;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        /* Loading */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #2a2a4a;
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Node styles for graph */
        .node {
            cursor: pointer;
        }

        .node-label {
            font-size: 11px;
            pointer-events: none;
            fill: #e0e0e0;
            text-anchor: middle;
        }

        .link {
            fill: none;
            stroke-opacity: 0.4;
            transition: all 0.3s;
        }

        .link.highlighted {
            stroke-opacity: 1;
            stroke-width: 3;
            stroke: #64ffda !important;
        }

        .node.highlighted circle {
            stroke: #64ffda;
            stroke-width: 3;
            filter: brightness(1.3);
        }

        .node.dimmed {
            opacity: 0.2;
        }

        .link.dimmed {
            opacity: 0.1;
        }

        .group-node {
            fill-opacity: 0.15;
            stroke-width: 2;
            cursor: pointer;
            transition: all 0.3s;
        }

        .group-node:hover {
            fill-opacity: 0.25;
            stroke-width: 3;
        }

        .group-node.focused {
            fill-opacity: 0.3;
            stroke-width: 4px;
            stroke: #64ffda;
        }

        .group-label {
            font-size: 14px;
            font-weight: 600;
            fill: #ffffff;
            text-anchor: middle;
            pointer-events: none;
            text-shadow: 0 0 4px rgba(0,0,0,0.8);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            color: #8892b0;
            padding: 20px;
            font-size: 14px;
        }

        .empty-state-icon {
            font-size: 2rem;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #0f0f23;
        }

        ::-webkit-scrollbar-thumb {
            background: #2a2a4a;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #3a3a5a;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Left Panel -->
        <div id="left-panel">
            <div class="upload-section">
                <label for="openapi-upload">
                    <div class="upload-btn">📁 OpenAPI 업로드</div>
                </label>
                <input type="file" id="openapi-upload" accept=".json">
                
                <label for="metrics-upload">
                    <div class="upload-btn">📊 메트릭 업로드</div>
                </label>
                <input type="file" id="metrics-upload" accept=".json">
            </div>

            <div class="search-section">
                <input type="text" class="search-input" placeholder="API 검색..." id="search-input">
            </div>

            <div class="stats-container">
                <div class="stat-card">
                    <div class="stat-value" id="stat-groups">0</div>
                    <div class="stat-label">그룹</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-apis">0</div>
                    <div class="stat-label">API</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-deps">0</div>
                    <div class="stat-label">의존성</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-cycles">0</div>
                    <div class="stat-label">순환</div>
                </div>
            </div>

            <div class="groups-section">
                <div class="section-title">API 그룹</div>
                <div id="groups-list"></div>
            </div>

            <div class="cycles-section" id="cycles-section" style="display: none;">
                <div class="section-title">순환 의존성</div>
                <div id="cycles-list"></div>
            </div>
        </div>

        <!-- Main Content -->
        <div id="main-content">
            <div id="header">
                <h1>🔍 API 의존성 분석기</h1>
                <span id="status" style="color: #8892b0; font-size: 14px;">파일을 업로드하거나 샘플 데이터를 로드하세요</span>
            </div>

            <div class="view-switcher">
                <button class="view-btn active" data-view="group">그룹뷰</button>
                <button class="view-btn" data-view="detail">상세뷰</button>
                <button class="view-btn" data-view="matrix">매트릭스</button>
            </div>

            <div id="canvas">
                <svg id="graph-svg"></svg>
                <div id="matrix-container"></div>
                
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="zoomIn()">+</button>
                    <button class="zoom-btn" onclick="zoomOut()">−</button>
                    <button class="zoom-btn" onclick="resetZoom()">⟲</button>
                    <button class="zoom-btn" onclick="fitToScreen()">⊡</button>
                </div>
                
                <div class="legend" id="legend" style="display: none;">
                    <!-- 범례는 동적으로 생성됨 -->
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div id="right-panel">
            <div id="node-info" style="display: none;">
                <div class="metric-card">
                    <div class="metric-title">선택된 항목</div>
                    <h3 id="selected-name" style="color: #64ffda; margin-bottom: 8px;">-</h3>
                    <div id="selected-details" class="metric-detail"></div>
                </div>

                <div class="metric-card">
                    <div class="metric-title">위험도 평가</div>
                    <div class="metric-value" id="risk-score">-</div>
                    <div class="risk-gauge">
                        <div class="risk-gauge-fill" id="risk-gauge"></div>
                    </div>
                    <div class="metric-detail" id="risk-detail"></div>
                </div>

                <div class="metric-card">
                    <div class="metric-title">의존성 분석</div>
                    <div class="metric-label">들어오는 의존성 (IN)</div>
                    <div class="dependency-list" id="in-dependencies"></div>
                    <div class="metric-label" style="margin-top: 12px;">나가는 의존성 (OUT)</div>
                    <div class="dependency-list" id="out-dependencies"></div>
                </div>

                <div class="metric-card">
                    <div class="metric-title">영향도</div>
                    <div class="metric-detail" id="impact-detail"></div>
                </div>
            </div>

            <div id="default-info">
                <div class="metric-card">
                    <div class="metric-title">시작하기</div>
                    <div class="metric-detail">
                        1. OpenAPI JSON 파일을 업로드하거나<br>
                        2. 샘플 데이터를 로드하세요<br>
                        3. 노드를 클릭하여 상세 정보를 확인하세요<br><br>
                        <strong>단축키:</strong><br>
                        • ESC: 포커스 해제<br>
                        • 빈 공간 클릭: 선택 해제
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Global state
        let nodes = [];
        let links = [];
        let groups = new Map();
        let metrics = new Map();
        let currentView = 'group';
        let simulation = null;
        let svg = null;
        let g = null;
        let focusedNode = null;
        let focusedGroup = null;
        let cycles = [];
        let zoom = null;

        // Group colors
        const groupColors = {
            'auth': '#c792ea',
            'authentication': '#c792ea',
            '인증·보안': '#c792ea',
            'user': '#64ffda',
            'users': '#64ffda',
            '사용자·멤버': '#64ffda',
            'product': '#ffcb6b',
            'products': '#ffcb6b',
            '상품·제품': '#ffcb6b',
            'order': '#f07178',
            'orders': '#f07178',
            '주문·장바구니': '#f07178',
            'payment': '#82aaff',
            'payments': '#82aaff',
            '구독·결제': '#82aaff',
            'admin': '#ff5370',
            '설정·관리자': '#ff5370',
            'report': '#c3e88d',
            'reports': '#c3e88d',
            '리포트·대시보드': '#c3e88d',
            'email': '#ffc777',
            '이메일·캠페인': '#ffc777',
            'integration': '#89ddff',
            '통합·연동': '#89ddff',
            'team': '#b2ccd6',
            '팀·조직': '#b2ccd6'
        };

        // Group mapping rules
        const groupMappings = {
            'auth': '인증·보안',
            'authentication': '인증·보안',
            'login': '인증·보안',
            'logout': '인증·보안',
            'user': '사용자·멤버',
            'users': '사용자·멤버',
            'member': '사용자·멤버',
            'profile': '사용자·멤버',
            'product': '상품·제품',
            'products': '상품·제품',
            'item': '상품·제품',
            'catalog': '상품·제품',
            'order': '주문·장바구니',
            'orders': '주문·장바구니',
            'cart': '주문·장바구니',
            'checkout': '주문·장바구니',
            'payment': '구독·결제',
            'payments': '구독·결제',
            'billing': '구독·결제',
            'subscription': '구독·결제',
            'admin': '설정·관리자',
            'settings': '설정·관리자',
            'config': '설정·관리자',
            'report': '리포트·대시보드',
            'reports': '리포트·대시보드',
            'dashboard': '리포트·대시보드',
            'analytics': '리포트·대시보드',
            'email': '이메일·캠페인',
            'campaign': '이메일·캠페인',
            'notification': '이메일·캠페인',
            'integration': '통합·연동',
            'webhook': '통합·연동',
            'api': '통합·연동',
            'team': '팀·조직',
            'organization': '팀·조직',
            'workspace': '팀·조직'
        };

        // Initialize with sample data for demo
        document.addEventListener('DOMContentLoaded', function() {
            init();
            // Auto-load sample data for demonstration
            setTimeout(() => {
                if (nodes.length === 0) {
                    loadSampleData();
                }
            }, 500);
        });

        function init() {
            setupEventListeners();
            initializeGraph();
        }

        function setupEventListeners() {
            // File uploads - 직접 이벤트 핸들러 연결
            const openapiInput = document.getElementById('openapi-upload');
            const metricsInput = document.getElementById('metrics-upload');
            
            if (openapiInput) {
                openapiInput.addEventListener('change', function(e) {
                    handleOpenAPIUpload(e);
                });
            }
            
            if (metricsInput) {
                metricsInput.addEventListener('change', function(e) {
                    handleMetricsUpload(e);
                });
            }

            // View switcher
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const view = e.target.dataset.view;
                    switchView(view);
                });
            });

            // Search
            const searchInput = document.getElementById('search-input');
            if (searchInput) {
                searchInput.addEventListener('input', handleSearch);
            }

            // ESC key to clear focus
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    clearFocus();
                }
            });
        }

        function initializeGraph() {
            const canvas = document.getElementById('canvas');
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;

            svg = d3.select('#graph-svg')
                .attr('width', width)
                .attr('height', height);

            // Create defs for arrows and gradients
            const defs = svg.append('defs');
            
            // Create arrow markers for different types
            const arrowTypes = [
                { id: 'arrow-normal', color: '#8892b0' },
                { id: 'arrow-highlighted', color: '#64ffda' },
                { id: 'arrow-crud', color: '#64ffda' },
                { id: 'arrow-auth-required', color: '#c792ea' },
                { id: 'arrow-workflow', color: '#f07178' },
                { id: 'arrow-reference', color: '#f78c6c' },
                { id: 'arrow-read-modify', color: '#82aaff' },
                { id: 'arrow-list-detail', color: '#ffcb6b' },
                { id: 'arrow-parent-child', color: '#c3e88d' },
                { id: 'arrow-user-action', color: '#89ddff' },
                { id: 'arrow-admin-control', color: '#ff5370' },
                { id: 'arrow-data-source', color: '#b2ccd6' },
                { id: 'arrow-incoming', color: '#EA4D08' },  // 들어오는 연결 - 주황색
                { id: 'arrow-outgoing', color: '#0c8ce9' }   // 나가는 연결 - 파란색
            ];
            
            arrowTypes.forEach(arrow => {
                defs.append('marker')
                    .attr('id', arrow.id)
                    .attr('viewBox', '0 -5 10 10')
                    .attr('refX', 25)
                    .attr('refY', 0)
                    .attr('markerWidth', 5)
                    .attr('markerHeight', 5)
                    .attr('orient', 'auto')
                    .attr('markerUnits', 'strokeWidth')
                    .append('path')
                    .attr('d', 'M0,-5L10,0L0,5')
                    .attr('fill', arrow.color)
                    .style('opacity', 0.8);
            });

            g = svg.append('g');

            // Zoom behavior
            zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);

            // Click on background to clear focus
            svg.on('click', function(event) {
                if (event.target === this || event.target === svg.node()) {
                    clearFocus();
                }
            });
        }

        async function handleOpenAPIUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                console.log('No file selected');
                return;
            }

            console.log('Loading OpenAPI file:', file.name);
            updateStatus('⏳ OpenAPI 파일 로딩 중...');

            try {
                const text = await file.text();
                console.log('File content loaded, parsing JSON...');
                const data = JSON.parse(text);
                
                if (!data.paths && !data.swagger && !data.openapi) {
                    throw new Error('유효한 OpenAPI/Swagger 파일이 아닙니다');
                }
                
                parseOpenAPI(data);
                updateStatus(`✅ OpenAPI 로드 완료: ${nodes.length}개 API, ${links.length}개 의존성`);
                renderGraph();
            } catch (error) {
                console.error('OpenAPI parsing error:', error);
                updateStatus('❌ OpenAPI 파싱 실패: ' + error.message);
                alert('OpenAPI 파일 처리 중 오류가 발생했습니다:\n' + error.message);
            }
        }

        async function handleMetricsUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                console.log('No file selected');
                return;
            }

            console.log('Loading metrics file:', file.name);
            updateStatus('⏳ 메트릭 파일 로딩 중...');

            try {
                const text = await file.text();
                console.log('File content loaded, parsing JSON...');
                const data = JSON.parse(text);
                
                if (!Array.isArray(data) && typeof data !== 'object') {
                    throw new Error('유효한 메트릭 파일이 아닙니다');
                }
                
                parseMetrics(data);
                updateStatus(`✅ 메트릭 로드 완료: ${metrics.size}개 API 메트릭`);
                if (nodes.length > 0) {
                    renderGraph();
                }
            } catch (error) {
                console.error('Metrics parsing error:', error);
                updateStatus('❌ 메트릭 파싱 실패: ' + error.message);
                alert('메트릭 파일 처리 중 오류가 발생했습니다:\n' + error.message);
            }
        }

        function parseOpenAPI(data) {
            console.log('Parsing OpenAPI data...');
            nodes = [];
            links = [];
            groups.clear();

            const nodeMap = new Map();

            const paths = data.paths || {};
            let apiCount = 0;
            
            if (Object.keys(paths).length === 0) {
                console.warn('No paths found in OpenAPI spec');
                updateStatus('⚠️ API 경로가 없습니다');
                return;
            }

            Object.entries(paths).forEach(([path, methods]) => {
                if (!methods || typeof methods !== 'object') return;
                
                Object.entries(methods).forEach(([method, spec]) => {
                    if (!['get', 'post', 'put', 'patch', 'delete', 'options', 'head'].includes(method.toLowerCase())) {
                        return;
                    }
                    
                    if (typeof spec !== 'object') return;

                    const apiId = `${method.toUpperCase()}_${path}`;
                    const apiName = spec.summary || spec.operationId || `${method.toUpperCase()} ${path}`;
                    const group = normalizeGroup(extractGroup(path, spec));

                    const node = {
                        id: apiId,
                        apiName: apiName,
                        method: method.toUpperCase(),
                        path: path,
                        group: group,
                        description: spec.description || '',
                        tags: spec.tags || [],
                        operationId: spec.operationId || ''
                    };

                    nodes.push(node);
                    nodeMap.set(apiId, node);
                    apiCount++;

                    if (!groups.has(group)) {
                        groups.set(group, {
                            name: group,
                            apis: [],
                            color: groupColors[group] || '#8892b0'
                        });
                    }
                    groups.get(group).apis.push(node);
                });
            });

            console.log(`Parsed ${apiCount} APIs in ${groups.size} groups`);

            analyzeDependencies();
            detectCycles();
            updateGroupsList();
            updateStats();
        }

        function extractGroup(path, spec) {
            if (spec.tags && spec.tags.length > 0) {
                return spec.tags[0].toLowerCase();
            }

            const pathParts = path.split('/').filter(p => p && !p.startsWith('{'));
            if (pathParts.length > 0) {
                return pathParts[0].toLowerCase();
            }

            return 'general';
        }

        function normalizeGroup(rawGroup) {
            const lower = rawGroup.toLowerCase();
            
            for (const [key, normalized] of Object.entries(groupMappings)) {
                if (lower.includes(key)) {
                    return normalized;
                }
            }

            return rawGroup;
        }

        function analyzeDependencies() {
            links = [];
            
            nodes.forEach(source => {
                nodes.forEach(target => {
                    if (source.id === target.id) return;
                    
                    const sourcePath = source.path.toLowerCase();
                    const targetPath = target.path.toLowerCase();
                    const sourceParts = source.path.split('/').filter(p => p && !p.startsWith('{'));
                    const targetParts = target.path.split('/').filter(p => p && !p.startsWith('{'));
                    const sourceResource = sourceParts[0] || '';
                    const targetResource = targetParts[0] || '';
                    
                    if (sourceResource && targetResource && 
                        (sourceResource === targetResource || 
                         sourceResource.includes(targetResource) || 
                         targetResource.includes(sourceResource))) {
                        
                        if (source.method === 'POST' && ['GET', 'PUT', 'DELETE', 'PATCH'].includes(target.method)) {
                            links.push({
                                source: source.id,
                                target: target.id,
                                type: 'crud',
                                weight: 3,
                                color: '#64ffda',
                                description: 'Create → Read/Update/Delete'
                            });
                        }
                        
                        if (source.method === 'GET' && ['PUT', 'DELETE', 'PATCH'].includes(target.method)) {
                            links.push({
                                source: source.id,
                                target: target.id,
                                type: 'read-modify',
                                weight: 2,
                                color: '#82aaff',
                                description: 'Read → Modify'
                            });
                        }
                        
                        if (source.method === 'GET' && !source.path.includes('{') && 
                            target.method === 'GET' && target.path.includes('{') &&
                            sourceResource === targetResource) {
                            links.push({
                                source: source.id,
                                target: target.id,
                                type: 'list-detail',
                                weight: 2,
                                color: '#ffcb6b',
                                description: 'List → Detail'
                            });
                        }
                    }
                    
                    if (source.group !== target.group) {
                        if ((source.group.includes('인증') || source.group.includes('auth')) && 
                            (source.path.includes('login') || source.path.includes('auth'))) {
                            if (target.method !== 'GET' || target.path.includes('profile') || target.path.includes('my')) {
                                links.push({
                                    source: source.id,
                                    target: target.id,
                                    type: 'auth-required',
                                    weight: 1,
                                    color: '#c792ea',
                                    description: 'Authentication Required'
                                });
                            }
                        }
                        
                        if ((source.group.includes('사용자') || source.group.includes('user')) &&
                            (target.group.includes('주문') || target.group.includes('order'))) {
                            if (source.method === 'GET' && target.method === 'POST') {
                                links.push({
                                    source: source.id,
                                    target: target.id,
                                    type: 'user-action',
                                    weight: 2,
                                    color: '#89ddff',
                                    description: 'User → Order'
                                });
                            }
                        }
                        
                        if ((source.group.includes('주문') || source.group.includes('order') || source.group.includes('cart')) &&
                            (target.group.includes('상품') || target.group.includes('product'))) {
                            links.push({
                                source: source.id,
                                target: target.id,
                                type: 'reference',
                                weight: 3,
                                color: '#f78c6c',
                                description: 'Order → Product Reference'
                            });
                        }
                        
                        if ((source.group.includes('주문') || source.group.includes('order')) &&
                            (target.group.includes('결제') || target.group.includes('payment'))) {
                            if (source.method === 'POST' && target.method === 'POST') {
                                links.push({
                                    source: source.id,
                                    target: target.id,
                                    type: 'workflow',
                                    weight: 4,
                                    color: '#f07178',
                                    description: 'Order → Payment Flow'
                                });
                            }
                        }
                        
                        if ((source.group.includes('상품') || source.group.includes('product')) &&
                            (target.path.includes('review') || target.path.includes('comment'))) {
                            links.push({
                                source: source.id,
                                target: target.id,
                                type: 'composition',
                                weight: 2,
                                color: '#c3e88d',
                                description: 'Product → Review'
                            });
                        }
                        
                        if ((source.group.includes('관리') || source.group.includes('admin')) &&
                            !target.group.includes('관리') && !target.group.includes('admin')) {
                            if (source.method === 'GET' && ['PUT', 'DELETE'].includes(target.method)) {
                                links.push({
                                    source: source.id,
                                    target: target.id,
                                    type: 'admin-control',
                                    weight: 1,
                                    color: '#ff5370',
                                    description: 'Admin Control'
                                });
                            }
                        }
                        
                        if ((source.group.includes('리포트') || source.group.includes('report') || source.group.includes('dashboard')) &&
                            ['GET'].includes(target.method)) {
                            links.push({
                                source: source.id,
                                target: target.id,
                                type: 'data-source',
                                weight: 1,
                                color: '#b2ccd6',
                                description: 'Report Data Source'
                            });
                        }
                    }
                    
                    if (targetPath.startsWith(sourcePath.replace(/\{[^}]+\}/g, '')) && 
                        sourcePath !== targetPath &&
                        sourcePath.length < targetPath.length) {
                        links.push({
                            source: source.id,
                            target: target.id,
                            type: 'parent-child',
                            weight: 2,
                            color: '#c3e88d',
                            description: 'Parent → Child Resource'
                        });
                    }
                    
                    if (source.method === 'GET' && target.method === 'POST' &&
                        sourceResource === targetResource) {
                        links.push({
                            source: source.id,
                            target: target.id,
                            type: 'read-create',
                            weight: 1,
                            color: '#b2ccd6',
                            description: 'Read → Create'
                        });
                    }
                    
                    if (source.method === 'POST' && target.method === 'GET' &&
                        sourceResource === targetResource && target.path.includes('{')) {
                        links.push({
                            source: source.id,
                            target: target.id,
                            type: 'create-read',
                            weight: 2,
                            color: '#89ddff',
                            description: 'Create → Read'
                        });
                    }
                });
            });
            
            const uniqueLinks = new Map();
            links.forEach(link => {
                const key = `${link.source}->${link.target}`;
                if (!uniqueLinks.has(key) || uniqueLinks.get(key).weight < link.weight) {
                    uniqueLinks.set(key, link);
                }
            });
            
            links = Array.from(uniqueLinks.values());
            console.log(`Generated ${links.length} unique dependencies`);
        }

        function parseMetrics(data) {
            console.log('Parsing metrics data...');
            metrics.clear();

            if (Array.isArray(data)) {
                data.forEach((metric, index) => {
                    const key = metric.id || 
                                metric.apiId || 
                                `${metric.method}_${metric.path}` ||
                                `metric_${index}`;
                    
                    metrics.set(key, {
                        calls: metric.calls || metric.count || metric.requests || 0,
                        p95: metric.p95 || metric.latency || metric.responseTime || 0,
                        errorRate: metric.errorRate || metric.errors || metric.error_rate || 0
                    });
                });
            } 
            else if (typeof data === 'object') {
                Object.entries(data).forEach(([key, metric]) => {
                    if (typeof metric === 'object') {
                        metrics.set(key, {
                            calls: metric.calls || metric.count || metric.requests || 0,
                            p95: metric.p95 || metric.latency || metric.responseTime || 0,
                            errorRate: metric.errorRate || metric.errors || metric.error_rate || 0
                        });
                    }
                });
            }

            console.log(`Parsed ${metrics.size} metrics`);
        }

        function detectCycles() {
            cycles = [];
            const index = new Map();
            const lowlink = new Map();
            const stack = [];
            const onStack = new Set();
            let idx = 0;

            function strongconnect(v) {
                index.set(v, idx);
                lowlink.set(v, idx);
                idx++;
                stack.push(v);
                onStack.add(v);

                const successors = links
                    .filter(l => l.source === v || (l.source.id && l.source.id === v))
                    .map(l => typeof l.target === 'string' ? l.target : l.target.id);

                for (const w of successors) {
                    if (!index.has(w)) {
                        strongconnect(w);
                        lowlink.set(v, Math.min(lowlink.get(v), lowlink.get(w)));
                    } else if (onStack.has(w)) {
                        lowlink.set(v, Math.min(lowlink.get(v), index.get(w)));
                    }
                }

                if (lowlink.get(v) === index.get(v)) {
                    const component = [];
                    let w;
                    do {
                        w = stack.pop();
                        onStack.delete(w);
                        component.push(w);
                    } while (w !== v);

                    if (component.length > 1) {
                        cycles.push(component);
                    }
                }
            }

            for (const node of nodes) {
                if (!index.has(node.id)) {
                    strongconnect(node.id);
                }
            }

            updateCyclesList();
        }

        function updateGroupsList() {
            const listEl = document.getElementById('groups-list');
            if (!listEl) return;
            
            listEl.innerHTML = '';

            if (groups.size === 0) {
                listEl.innerHTML = '<div class="empty-state"><div class="empty-state-icon">📂</div>데이터를 로드하세요</div>';
                return;
            }

            groups.forEach((group, groupName) => {
                const item = document.createElement('div');
                item.className = 'group-item';
                if (focusedGroup === groupName) {
                    item.classList.add('active');
                }
                item.innerHTML = `
                    <span class="group-name">${groupName}</span>
                    <span class="group-count">${group.apis.length}</span>
                `;
                item.addEventListener('click', () => focusGroup(groupName));
                listEl.appendChild(item);
            });
            
            updateLegend();
        }
        
        function updateLegend() {
            const legendEl = document.getElementById('legend');
            if (!legendEl) return;
            
            if (groups.size === 0) {
                legendEl.style.display = 'none';
                return;
            }
            
            legendEl.style.display = 'block';
            legendEl.innerHTML = '';
            
            const title = document.createElement('div');
            title.style.fontSize = '11px';
            title.style.color = '#8892b0';
            title.style.marginBottom = '8px';
            title.style.fontWeight = '600';
            title.textContent = 'API 그룹';
            legendEl.appendChild(title);
            
            groups.forEach((group, groupName) => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background: ${group.color};"></div>
                    <span>${groupName} (${group.apis.length})</span>
                `;
                legendEl.appendChild(item);
            });
        }

        function updateCyclesList() {
            const section = document.getElementById('cycles-section');
            const listEl = document.getElementById('cycles-list');
            
            if (!section || !listEl) return;
            
            if (cycles.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            listEl.innerHTML = '';

            cycles.forEach((cycle, idx) => {
                const item = document.createElement('div');
                item.className = 'cycle-item';
                item.innerHTML = `
                    <div>순환 의존성 #${idx + 1}</div>
                    <div class="cycle-nodes">${cycle.slice(0, 3).join(' → ')}${cycle.length > 3 ? ' ...' : ''}</div>
                `;
                item.addEventListener('click', () => focusCycle(cycle));
                listEl.appendChild(item);
            });
        }

        function renderGraph() {
            if (currentView === 'matrix') {
                renderMatrix();
                return;
            }

            document.getElementById('graph-svg').style.display = 'block';
            document.getElementById('matrix-container').style.display = 'none';

            g.selectAll('*').remove();

            const canvas = document.getElementById('canvas');
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;

            if (currentView === 'group') {
                renderGroupView(width, height);
            } else {
                renderDetailView(width, height);
            }
        }

        function renderGroupView(width, height) {
            const groupNodes = Array.from(groups.values()).map(g => ({
                ...g,
                id: g.name,
                radius: Math.sqrt(g.apis.length) * 20 + 30
            }));

            const groupLinkMap = new Map();
            links.forEach(link => {
                const sourceNode = nodes.find(n => n.id === link.source);
                const targetNode = nodes.find(n => n.id === link.target);
                if (sourceNode && targetNode && sourceNode.group !== targetNode.group) {
                    const key = `${sourceNode.group}->${targetNode.group}`;
                    if (!groupLinkMap.has(key)) {
                        groupLinkMap.set(key, {
                            source: sourceNode.group,
                            target: targetNode.group,
                            count: 0,
                            weight: 0
                        });
                    }
                    const groupLink = groupLinkMap.get(key);
                    groupLink.count++;
                    groupLink.weight += link.weight || 1;
                }
            });

            const groupLinks = Array.from(groupLinkMap.values());

            simulation = d3.forceSimulation(groupNodes)
                .force('link', d3.forceLink(groupLinks).id(d => d.id).distance(200))
                .force('charge', d3.forceManyBody().strength(-800))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => d.radius + 20));

            const linkGroup = g.append('g').attr('class', 'links');
            const nodeGroup = g.append('g').attr('class', 'nodes');

            const link = linkGroup.selectAll('line')
                .data(groupLinks)
                .enter().append('line')
                .attr('class', 'link')
                .attr('stroke', '#666')
                .attr('stroke-width', d => Math.max(1, Math.log(d.count + 1)))
                .attr('stroke-opacity', 0.6)
                .attr('marker-end', 'url(#arrow-normal)');

            const node = nodeGroup.selectAll('.node')
                .data(groupNodes)
                .enter().append('g')
                .attr('class', 'node')
                .call(drag(simulation))
                .on('click', (event, d) => {
                    event.stopPropagation();
                    focusGroup(d.name);
                })
                .on('mouseover', function(event, d) {
                    showGroupTooltip(event, d);
                    
                    linkGroup.selectAll('line')
                        .style('stroke', function(linkData) {
                            if (linkData.source.id === d.id || linkData.source === d.id) {
                                return '#0c8ce9';
                            } else if (linkData.target.id === d.id || linkData.target === d.id) {
                                return '#EA4D08';
                            }
                            return '#666';
                        })
                        .style('stroke-dasharray', function(linkData) {
                            if (linkData.source.id === d.id || linkData.source === d.id) {
                                return '5,5';
                            }
                            return 'none';
                        })
                        .style('stroke-width', function(linkData) {
                            if ((linkData.source.id === d.id || linkData.source === d.id) ||
                                (linkData.target.id === d.id || linkData.target === d.id)) {
                                return Math.max(2, Math.log(linkData.count + 1) * 1.5);
                            }
                            return Math.max(1, Math.log(linkData.count + 1));
                        })
                        .style('stroke-opacity', function(linkData) {
                            if ((linkData.source.id === d.id || linkData.source === d.id) ||
                                (linkData.target.id === d.id || linkData.target === d.id)) {
                                return 1;
                            }
                            return 0.2;
                        });
                    
                    nodeGroup.selectAll('.node')
                        .style('opacity', function(nodeData) {
                            const isConnected = groupLinks.some(link => 
                                (link.source.id === d.id && link.target.id === nodeData.id) ||
                                (link.target.id === d.id && link.source.id === nodeData.id) ||
                                (link.source === d.id && link.target === nodeData.id) ||
                                (link.target === d.id && link.source === nodeData.id)
                            );
                            
                            if (nodeData.id === d.id || isConnected) {
                                return 1;
                            }
                            return 0.4;
                        });
                })
                .on('mouseout', function(event, d) {
                    hideTooltip();
                    
                    linkGroup.selectAll('line')
                        .style('stroke', '#666')
                        .style('stroke-dasharray', 'none')
                        .style('stroke-width', linkData => Math.max(1, Math.log(linkData.count + 1)))
                        .style('stroke-opacity', 0.6);
                    
                    nodeGroup.selectAll('.node')
                        .style('opacity', 1);
                });

            node.append('circle')
                .attr('class', 'group-node')
                .attr('r', d => d.radius)
                .attr('fill', d => d.color)
                .attr('stroke', d => d.color);

            node.append('text')
                .attr('class', 'group-label')
                .attr('dy', -5)
                .text(d => d.name);

            node.append('text')
                .attr('class', 'node-label')
                .attr('dy', 10)
                .text(d => `${d.apis.length} APIs`);

            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });
        }

        function renderDetailView(width, height) {
            const simNodes = nodes.map(n => ({...n}));
            const simLinks = links.map(l => ({...l}));

            console.log(`Rendering detail view with ${simNodes.length} nodes and ${simLinks.length} links`);

            simulation = d3.forceSimulation(simNodes)
                .force('link', d3.forceLink(simLinks)
                    .id(d => d.id)
                    .distance(d => 120 + (d.weight * 10)))
                .force('charge', d3.forceManyBody().strength(-600))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(35))
                .force('x', d3.forceX(width / 2).strength(0.05))
                .force('y', d3.forceY(height / 2).strength(0.05));

            const linkGroup = g.append('g').attr('class', 'links');
            const nodeGroup = g.append('g').attr('class', 'nodes');

            const link = linkGroup.selectAll('.link')
                .data(simLinks)
                .enter().append('line')
                .attr('class', 'link')
                .attr('stroke', d => d.color || '#666')
                .attr('stroke-width', d => Math.max(1, Math.sqrt(d.weight)))
                .attr('stroke-opacity', 0.6)
                .attr('marker-end', d => `url(#arrow-${d.type || 'normal'})`)
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    d3.select(this)
                        .attr('stroke-width', Math.max(2, Math.sqrt(d.weight) * 1.5))
                        .attr('stroke-opacity', 1);
                    
                    const sourceNode = simNodes.find(n => n.id === (d.source.id || d.source));
                    const targetNode = simNodes.find(n => n.id === (d.target.id || d.target));
                    
                    const tooltip = document.getElementById('tooltip');
                    tooltip.innerHTML = `
                        <h4 style="color: #ffffff;">의존성: ${d.type}</h4>
                        <div class="tooltip-row">
                            <span class="tooltip-label">From:</span>
                            <span class="tooltip-value">${sourceNode?.apiName || d.source}</span>
                        </div>
                        <div class="tooltip-row">
                            <span class="tooltip-label">To:</span>
                            <span class="tooltip-value">${targetNode?.apiName || d.target}</span>
                        </div>
                        <div class="tooltip-row">
                            <span class="tooltip-label">타입:</span>
                            <span class="tooltip-value">${d.description || d.type}</span>
                        </div>
                        <div class="tooltip-row">
                            <span class="tooltip-label">가중치:</span>
                            <span class="tooltip-value">${d.weight}</span>
                        </div>
                    `;
                    tooltip.style.left = event.pageX + 10 + 'px';
                    tooltip.style.top = event.pageY + 10 + 'px';
                    tooltip.classList.add('show');
                })
                .on('mouseout', function(event, d) {
                    d3.select(this)
                        .attr('stroke-width', Math.max(1, Math.sqrt(d.weight)))
                        .attr('stroke-opacity', 0.6);
                    hideTooltip();
                });

            const gradient = svg.select('defs')
                .selectAll('radialGradient')
                .data(simNodes)
                .enter().append('radialGradient')
                .attr('id', d => `gradient-${d.id.replace(/[^a-zA-Z0-9]/g, '')}`)
                .attr('cx', '30%')
                .attr('cy', '30%');

            gradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', d => {
                    const baseColor = groupColors[d.group] || '#8892b0';
                    return d3.color(baseColor).brighter(0.5);
                });

            gradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', d => groupColors[d.group] || '#8892b0');

            const node = nodeGroup.selectAll('.node')
                .data(simNodes)
                .enter().append('g')
                .attr('class', 'node')
                .style('cursor', 'pointer')
                .call(drag(simulation))
                .on('click', (event, d) => {
                    event.stopPropagation();
                    focusNode(d);
                })
                .on('mouseover', function(event, d) {
                    showNodeTooltip(event, d);
                    
                    linkGroup.selectAll('.link')
                        .style('stroke', function(linkData) {
                            const sourceId = linkData.source.id || linkData.source;
                            const targetId = linkData.target.id || linkData.target;
                            
                            if (sourceId === d.id) {
                                return '#0c8ce9';
                            } else if (targetId === d.id) {
                                return '#EA4D08';
                            }
                            return linkData.color || '#666';
                        })
                        .style('stroke-dasharray', function(linkData) {
                            const sourceId = linkData.source.id || linkData.source;
                            
                            if (sourceId === d.id) {
                                return '5,5';
                            }
                            return 'none';
                        })
                        .style('stroke-width', function(linkData) {
                            const sourceId = linkData.source.id || linkData.source;
                            const targetId = linkData.target.id || linkData.target;
                            
                            if (sourceId === d.id || targetId === d.id) {
                                return Math.max(2, Math.sqrt(linkData.weight) * 1.5);
                            }
                            return Math.max(1, Math.sqrt(linkData.weight));
                        })
                        .style('stroke-opacity', function(linkData) {
                            const sourceId = linkData.source.id || linkData.source;
                            const targetId = linkData.target.id || linkData.target;
                            
                            if (sourceId === d.id || targetId === d.id) {
                                return 1;
                            }
                            return 0.3;
                        });
                    
                    nodeGroup.selectAll('.node')
                        .style('opacity', function(nodeData) {
                            const isConnected = links.some(link => {
                                const sourceId = link.source.id || link.source;
                                const targetId = link.target.id || link.target;
                                return (sourceId === d.id && targetId === nodeData.id) ||
                                       (targetId === d.id && sourceId === nodeData.id);
                            });
                            
                            if (nodeData.id === d.id || isConnected) {
                                return 1;
                            }
                            return 0.5;
                        });
                })
                .on('mouseout', function(event, d) {
                    hideTooltip();
                    
                    linkGroup.selectAll('.link')
                        .style('stroke', linkData => linkData.color || '#666')
                        .style('stroke-dasharray', 'none')
                        .style('stroke-width', linkData => Math.max(1, Math.sqrt(linkData.weight)))
                        .style('stroke-opacity', 0.6);
                    
                    nodeGroup.selectAll('.node')
                        .style('opacity', 1);
                });

            node.append('circle')
                .attr('r', d => {
                    const metric = metrics.get(d.id);
                    const baseSize = 20;
                    if (metric) {
                        return Math.max(15, Math.min(35, baseSize + Math.sqrt(metric.calls / 100)));
                    }
                    return baseSize;
                })
                .attr('fill', d => `url(#gradient-${d.id.replace(/[^a-zA-Z0-9]/g, '')})`)
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.3))');

            node.append('text')
                .attr('class', 'node-label')
                .attr('dy', -28)
                .attr('text-anchor', 'middle')
                .text(d => d.method)
                .style('font-size', '11px')
                .style('font-weight', 'bold')
                .style('fill', d => {
                    const methodColor = {
                        'GET': '#64ffda',
                        'POST': '#f07178',
                        'PUT': '#ffcb6b',
                        'PATCH': '#ffcb6b',
                        'DELETE': '#c792ea'
                    };
                    return methodColor[d.method] || '#8892b0';
                })
                .style('text-shadow', '0 1px 2px rgba(0,0,0,0.8)');

            node.append('text')
                .attr('class', 'node-label')
                .attr('dy', 4)
                .attr('text-anchor', 'middle')
                .text(d => {
                    if (d.apiName && d.apiName !== d.id) {
                        return d.apiName.length > 20 ? d.apiName.substring(0, 20) + '...' : d.apiName;
                    }
                    const parts = d.path.split('/').filter(p => p && !p.startsWith('{'));
                    const resource = parts[parts.length - 1] || parts[0] || 'api';
                    return resource.length > 15 ? resource.substring(0, 15) + '...' : resource;
                })
                .style('font-size', '11px')
                .style('font-weight', '500')
                .style('fill', '#ffffff')
                .style('text-shadow', '0 1px 3px rgba(0,0,0,0.9)')
                .style('pointer-events', 'none');

            node.append('text')
                .attr('class', 'node-label')
                .attr('dy', 38)
                .attr('text-anchor', 'middle')
                .text(d => {
                    const shortPath = d.path.length > 20 ? 
                        '...' + d.path.substring(d.path.length - 17) : d.path;
                    return shortPath;
                })
                .style('font-size', '9px')
                .style('fill', '#8892b0')
                .style('opacity', 0.8)
                .style('text-shadow', '0 1px 2px rgba(0,0,0,0.8)');

            node.append('text')
                .attr('class', 'node-label')
                .attr('dy', -40)
                .attr('text-anchor', 'middle')
                .text(d => d.group)
                .style('font-size', '9px')
                .style('fill', '#8892b0')
                .style('opacity', 0.7);

            node.each(function(d) {
                const metric = metrics.get(d.id);
                if (metric && metric.calls > 10000) {
                    d3.select(this).select('circle')
                        .style('animation', 'pulse 2s infinite');
                }
                
                if (metric && metric.errorRate > 0.05) {
                    d3.select(this).append('circle')
                        .attr('r', 4)
                        .attr('cx', 18)
                        .attr('cy', -18)
                        .attr('fill', '#f07178')
                        .style('filter', 'drop-shadow(0 0 3px rgba(240, 113, 120, 0.8))');
                }
            });

            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            simulation.alpha(1).restart();

            if (!document.getElementById('pulse-animation')) {
                const style = document.createElement('style');
                style.id = 'pulse-animation';
                style.textContent = `
                    @keyframes pulse {
                        0% { stroke-width: 2; stroke-opacity: 1; }
                        50% { stroke-width: 4; stroke-opacity: 0.6; }
                        100% { stroke-width: 2; stroke-opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
            }
        }

        function renderMatrix() {
            document.getElementById('graph-svg').style.display = 'none';
            document.getElementById('matrix-container').style.display = 'block';

            const container = document.getElementById('matrix-container');
            container.innerHTML = '';

            const margin = {top: 100, right: 50, bottom: 50, left: 100};
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;

            const matrixSvg = d3.select(container)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);

            const matrixG = matrixSvg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const groupNames = Array.from(groups.keys());
            const cellSize = Math.min(width / groupNames.length, height / groupNames.length, 50);

            const matrix = [];
            groupNames.forEach(source => {
                groupNames.forEach(target => {
                    const connections = links.filter(l => {
                        const sourceNode = nodes.find(n => n.id === l.source);
                        const targetNode = nodes.find(n => n.id === l.target);
                        return sourceNode?.group === source && targetNode?.group === target;
                    });
                    if (connections.length > 0) {
                        matrix.push({
                            source: source,
                            target: target,
                            value: connections.length,
                            weight: connections.reduce((sum, c) => sum + (c.weight || 1), 0)
                        });
                    }
                });
            });

            const xScale = d3.scaleBand()
                .domain(groupNames)
                .range([0, groupNames.length * cellSize])
                .padding(0.1);

            const yScale = d3.scaleBand()
                .domain(groupNames)
                .range([0, groupNames.length * cellSize])
                .padding(0.1);

            const colorScale = d3.scaleSequential()
                .domain([0, d3.max(matrix, d => d.value)])
                .interpolator(d3.interpolateBlues);

            matrixG.selectAll('.matrix-cell')
                .data(matrix)
                .enter().append('rect')
                .attr('class', 'matrix-cell')
                .attr('x', d => xScale(d.target))
                .attr('y', d => yScale(d.source))
                .attr('width', xScale.bandwidth())
                .attr('height', yScale.bandwidth())
                .attr('fill', d => colorScale(d.value))
                .attr('stroke', '#2a2a4a')
                .on('click', (event, d) => {
                    showMatrixDetail(d.source, d.target);
                })
                .on('mouseover', (event, d) => {
                    showMatrixTooltip(event, d);
                })
                .on('mouseout', hideTooltip);

            matrixG.selectAll('.matrix-text')
                .data(matrix)
                .enter().append('text')
                .attr('x', d => xScale(d.target) + xScale.bandwidth() / 2)
                .attr('y', d => yScale(d.source) + yScale.bandwidth() / 2)
                .attr('dy', 4)
                .attr('text-anchor', 'middle')
                .style('fill', d => d.value > 3 ? 'white' : '#2a2a4a')
                .style('font-size', '11px')
                .style('pointer-events', 'none')
                .text(d => d.value);

            matrixG.selectAll('.row-label')
                .data(groupNames)
                .enter().append('text')
                .attr('class', 'matrix-label')
                .attr('x', -10)
                .attr('y', d => yScale(d) + yScale.bandwidth() / 2)
                .attr('text-anchor', 'end')
                .attr('dy', 4)
                .text(d => d.length > 10 ? d.substring(0, 10) + '...' : d);

            matrixG.selectAll('.col-label')
                .data(groupNames)
                .enter().append('text')
                .attr('class', 'matrix-label')
                .attr('x', d => xScale(d) + xScale.bandwidth() / 2)
                .attr('y', -10)
                .attr('text-anchor', 'start')
                .attr('transform', d => `rotate(-45, ${xScale(d) + xScale.bandwidth() / 2}, -10)`)
                .text(d => d.length > 10 ? d.substring(0, 10) + '...' : d);
        }

        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            return d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended);
        }

        function focusNode(node) {
            focusedNode = node;
            focusedGroup = null;
            updateNodeInfo(node);
            highlightNodeConnections(node);
            
            document.querySelectorAll('.group-item').forEach(item => {
                const name = item.querySelector('.group-name').textContent;
                item.classList.toggle('active', name === node.group);
            });
        }

        function focusGroup(groupName) {
            focusedGroup = groupName;
            focusedNode = null;
            
            const group = groups.get(groupName);
            if (group) {
                updateGroupInfo(group);
                highlightGroupConnections(groupName);
            }
            
            updateGroupsList();
        }

        function focusCycle(cycle) {
            g.selectAll('.node')
                .classed('highlighted', d => cycle.includes(d.id))
                .classed('dimmed', d => !cycle.includes(d.id));

            g.selectAll('.link')
                .classed('highlighted', d => {
                    const sourceId = d.source.id || d.source;
                    const targetId = d.target.id || d.target;
                    return cycle.includes(sourceId) && cycle.includes(targetId);
                })
                .classed('dimmed', d => {
                    const sourceId = d.source.id || d.source;
                    const targetId = d.target.id || d.target;
                    return !cycle.includes(sourceId) || !cycle.includes(targetId);
                });
        }

        function highlightNodeConnections(node) {
            const connectedNodes = new Set([node.id]);
            links.forEach(link => {
                const sourceId = link.source.id || link.source;
                const targetId = link.target.id || link.target;
                
                if (targetId === node.id) {
                    connectedNodes.add(sourceId);
                } else if (sourceId === node.id) {
                    connectedNodes.add(targetId);
                }
            });

            g.selectAll('.node')
                .classed('highlighted', d => d.id === node.id)
                .classed('dimmed', d => !connectedNodes.has(d.id))
                .selectAll('circle')
                .style('stroke', d => {
                    if (d.id === node.id) return '#64ffda';
                    return connectedNodes.has(d.id) ? '#fff' : '#2a2a4a';
                })
                .style('stroke-width', d => {
                    if (d.id === node.id) return 3;
                    return connectedNodes.has(d.id) ? 2 : 1;
                });

            g.selectAll('.link')
                .style('stroke', function(d) {
                    const sourceId = d.source.id || d.source;
                    const targetId = d.target.id || d.target;
                    
                    if (sourceId === node.id) return '#0c8ce9'; // Outgoing
                    if (targetId === node.id) return '#EA4D08'; // Incoming
                    return d.color || '#666';
                })
                .style('stroke-dasharray', function(d) {
                    const sourceId = d.source.id || d.source;
                    if (sourceId === node.id) return '5,5'; // Outgoing
                    return 'none'; // Incoming
                })
                .style('stroke-width', function(d) {
                    const sourceId = d.source.id || d.source;
                    const targetId = d.target.id || d.target;
                    if (sourceId === node.id || targetId === node.id) {
                        return Math.max(2, Math.sqrt(d.weight || 1) * 1.5);
                    }
                    return Math.max(1, Math.sqrt(d.weight || 1));
                })
                .style('stroke-opacity', function(d) {
                    const sourceId = d.source.id || d.source;
                    const targetId = d.target.id || d.target;
                    if (sourceId === node.id || targetId === node.id) return 1;
                    return 0.1;
                })
                .attr('marker-end', function(d) {
                    const sourceId = d.source.id || d.source;
                    const targetId = d.target.id || d.target;
                    if (sourceId === node.id) return 'url(#arrow-outgoing)';
                    if (targetId === node.id) return 'url(#arrow-incoming)';
                    return `url(#arrow-${d.type || 'normal'})`;
                })
                .classed('dimmed', d => {
                    const sourceId = d.source.id || d.source;
                    const targetId = d.target.id || d.target;
                    return sourceId !== node.id && targetId !== node.id;
                });
        }

        function highlightGroupConnections(groupName) {
            const connectedGroups = new Set([groupName]);
            links.forEach(link => {
                const sourceNode = nodes.find(n => n.id === link.source);
                const targetNode = nodes.find(n => n.id === link.target);
                if (!sourceNode || !targetNode) return;
                if (sourceNode.group === groupName) connectedGroups.add(targetNode.group);
                if (targetNode.group === groupName) connectedGroups.add(sourceNode.group);
            });

            g.selectAll('.node').selectAll('circle.group-node')
                .classed('focused', d => d.name === groupName)
                .classed('dimmed', d => !connectedGroups.has(d.name));

            g.selectAll('.link')
                .style('stroke', function(d) {
                    const sourceName = d.source.name || d.source.id || d.source;
                    const targetName = d.target.name || d.target.id || d.target;
                    if (sourceName === groupName) return '#0c8ce9'; // Outgoing
                    if (targetName === groupName) return '#EA4D08'; // Incoming
                    return '#666';
                })
                .style('stroke-dasharray', function(d) {
                    const sourceName = d.source.name || d.source.id || d.source;
                    if (sourceName === groupName) return '5,5'; // Outgoing
                    return 'none'; // Incoming
                })
                .style('stroke-width', function(d) {
                    const sourceName = d.source.name || d.source.id || d.source;
                    const targetName = d.target.name || d.target.id || d.target;
                    if (sourceName === groupName || targetName === groupName) return Math.max(2, Math.log((d.count || 1) + 1) * 1.5);
                    return Math.max(1, Math.log((d.count || 1) + 1));
                })
                .style('stroke-opacity', function(d) {
                    const sourceName = d.source.name || d.source.id || d.source;
                    const targetName = d.target.name || d.target.id || d.target;
                    if (sourceName === groupName || targetName === groupName) return 1;
                    return 0.1;
                })
                .attr('marker-end', function(d) {
                    const sourceName = d.source.name || d.source.id || d.source;
                    const targetName = d.target.name || d.target.id || d.target;
                    if (sourceName === groupName) return 'url(#arrow-outgoing)';
                    if (targetName === groupName) return 'url(#arrow-incoming)';
                    return 'url(#arrow-normal)';
                })
                .classed('dimmed', d => {
                    const sourceName = d.source.name || d.source.id || d.source;
                    const targetName = d.target.name || d.target.id || d.target;
                    return sourceName !== groupName && targetName !== groupName;
                });
        }

        function clearFocus() {
            focusedNode = null;
            focusedGroup = null;

            g.selectAll('.node, .group-node').classed('highlighted focused dimmed', false).style('stroke', null).style('stroke-width', null);
            g.selectAll('.link').classed('highlighted dimmed', false).style('stroke', null).style('stroke-width', null).style('stroke-opacity', null).style('stroke-dasharray', null).attr('marker-end', d => `url(#arrow-${d.type || 'normal'})`);
            
            document.querySelectorAll('.group-item').forEach(item => item.classList.remove('active'));

            document.getElementById('node-info').style.display = 'none';
            document.getElementById('default-info').style.display = 'block';
        }

        function updateNodeInfo(node) {
            document.getElementById('default-info').style.display = 'none';
            document.getElementById('node-info').style.display = 'block';

            document.getElementById('selected-name').textContent = node.apiName;
            document.getElementById('selected-details').innerHTML = `
                <div><strong>메소드:</strong> ${node.method}</div>
                <div><strong>경로:</strong> ${node.path}</div>
                <div><strong>그룹:</strong> ${node.group}</div>
                ${node.description ? `<div><strong>설명:</strong> ${node.description}</div>` : ''}
            `;

            const riskScore = calculateRiskScore(node);
            document.getElementById('risk-score').textContent = riskScore.score.toFixed(1);
            document.getElementById('risk-gauge').style.width = `${riskScore.score * 10}%`;
            document.getElementById('risk-detail').innerHTML = riskScore.details.join('<br>');

            updateDependencies(node);
            updateImpact(node);
        }

        function updateGroupInfo(group) {
            document.getElementById('default-info').style.display = 'none';
            document.getElementById('node-info').style.display = 'block';

            // 메소드 분포 계산
            const methodCounts = group.apis.reduce((acc, api) => {
                acc[api.method] = (acc[api.method] || 0) + 1;
                return acc;
            }, {});
            const methodDistribution = Object.entries(methodCounts)
                .map(([method, count]) => `${method}: ${count}`)
                .join(' ');

            document.getElementById('selected-name').textContent = group.name;
            document.getElementById('selected-details').innerHTML = `
                <div><strong>API 수:</strong> ${group.apis.length}</div>
                <div><strong>메소드 분포:</strong> ${methodDistribution}</div>
            `;

            // 그룹 단위 위험도 계산
            const inDeps = new Set();
            const outDeps = new Set();
            links.forEach(link => {
                const sourceNode = nodes.find(n => n.id === (link.source.id || link.source));
                const targetNode = nodes.find(n => n.id === (link.target.id || link.target));
                if (!sourceNode || !targetNode || sourceNode.group === targetNode.group) return;

                if (targetNode.group === group.name) inDeps.add(link);
                if (sourceNode.group === group.name) outDeps.add(link);
            });
            const inCount = inDeps.size;
            const outCount = outDeps.size;

            const riskScore = Math.min(10, (inCount * 2 + outCount) / 5.0); // 점수 스케일링
            const riskLevel = riskScore < 3 ? '낮음' : riskScore < 7 ? '중간' : '높음';

            document.getElementById('risk-score').textContent = riskScore.toFixed(1);
            document.getElementById('risk-gauge').style.width = `${riskScore * 10}%`;
            document.getElementById('risk-detail').innerHTML = `
                <strong>위험도: ${riskLevel}</strong><br>
                • ${inCount}개의 들어오는 의존성 (×2)<br>
                • ${outCount}개의 나가는 의존성 (×1)
            `;

            updateGroupDependencies(group);
        }

        function calculateRiskScore(node) {
            const details = [];
            
            const inDeps = links.filter(l => (l.target.id || l.target) === node.id).length;
            const outDeps = links.filter(l => (l.source.id || l.source) === node.id).length;
            const depScore = Math.min(4, Math.log1p(inDeps * 1.5 + outDeps) * 1.2);
            details.push(`• 의존성 점수: ${depScore.toFixed(1)}/4.0`);

            let criticalityScore = 0;
            if (node.method === 'DELETE') {
                criticalityScore += 1.5;
                details.push(`• 메소드 위험 (DELETE): +1.5`);
            } else if (['PUT', 'PATCH'].includes(node.method)) {
                criticalityScore += 0.7;
                details.push(`• 메소드 위험 (PUT/PATCH): +0.7`);
            }
            
            if (node.group.includes('인증') || node.group.includes('보안')) {
                criticalityScore += 2.0;
                details.push(`• 그룹 중요도 (인증/보안): +2.0`);
            } else if (node.group.includes('결제')) {
                criticalityScore += 1.5;
                details.push(`• 그룹 중요도 (결제): +1.5`);
            }

            let metricsScore = 0;
            const metric = metrics.get(node.id);
            if (metric) {
                if (metric.errorRate > 0.05) {
                    metricsScore += 1.5;
                    details.push(`• 높은 오류율 (${(metric.errorRate * 100).toFixed(1)}%): +1.5`);
                }
                if (metric.p95 > 1000) {
                    metricsScore += 1.0;
                    details.push(`• 높은 지연시간 (${metric.p95}ms): +1.0`);
                }
                if (metric.calls > 10000) {
                    metricsScore += 0.5;
                    details.push(`• 높은 호출량: +0.5`);
                }
            }

            let score = depScore + criticalityScore + metricsScore;
            score = Math.min(10, score);

            const level = score < 3 ? '낮음' : score < 7 ? '중간' : '높음';
            details.unshift(`<strong>위험도: ${level}</strong>`);

            return { score, details };
        }

        function updateDependencies(node) {
            const inDeps = [];
            const outDeps = [];

            links.forEach(link => {
                const sourceId = link.source.id || link.source;
                const targetId = link.target.id || link.target;
                
                if (targetId === node.id) {
                    const sourceNode = nodes.find(n => n.id === sourceId);
                    if (sourceNode) inDeps.push({ node: sourceNode, type: link.type, weight: link.weight });
                } else if (sourceId === node.id) {
                    const targetNode = nodes.find(n => n.id === targetId);
                    if (targetNode) outDeps.push({ node: targetNode, type: link.type, weight: link.weight });
                }
            });

            const inList = document.getElementById('in-dependencies');
            inList.innerHTML = inDeps.length === 0 ? '<div style="color: #8892b0;">없음</div>' : '';
            inDeps.forEach(dep => {
                const item = document.createElement('div');
                item.className = 'dependency-item incoming';
                item.innerHTML = `<div>${dep.node.apiName}</div><div class="dependency-type">타입: ${dep.type} | 가중치: ${dep.weight}</div>`;
                item.addEventListener('click', () => focusNode(dep.node));
                inList.appendChild(item);
            });

            const outList = document.getElementById('out-dependencies');
            outList.innerHTML = outDeps.length === 0 ? '<div style="color: #8892b0;">없음</div>' : '';
            outDeps.forEach(dep => {
                const item = document.createElement('div');
                item.className = 'dependency-item outgoing';
                item.innerHTML = `<div>${dep.node.apiName}</div><div class="dependency-type">타입: ${dep.type} | 가중치: ${dep.weight}</div>`;
                item.addEventListener('click', () => focusNode(dep.node));
                outList.appendChild(item);
            });
        }

        function updateGroupDependencies(group) {
            const inGroups = new Map();
            const outGroups = new Map();

            group.apis.forEach(api => {
                links.forEach(link => {
                    const sourceId = link.source.id || link.source;
                    const targetId = link.target.id || link.target;
                    
                    if (targetId === api.id) {
                        const sourceNode = nodes.find(n => n.id === sourceId);
                        if (sourceNode && sourceNode.group !== group.name) {
                            if (!inGroups.has(sourceNode.group)) inGroups.set(sourceNode.group, 0);
                            inGroups.set(sourceNode.group, inGroups.get(sourceNode.group) + 1);
                        }
                    } else if (sourceId === api.id) {
                        const targetNode = nodes.find(n => n.id === targetId);
                        if (targetNode && targetNode.group !== group.name) {
                            if (!outGroups.has(targetNode.group)) outGroups.set(targetNode.group, 0);
                            outGroups.set(targetNode.group, outGroups.get(targetNode.group) + 1);
                        }
                    }
                });
            });

            const inList = document.getElementById('in-dependencies');
            inList.innerHTML = inGroups.size === 0 ? '<div style="color: #8892b0;">없음</div>' : '';
            inGroups.forEach((count, groupName) => {
                const item = document.createElement('div');
                item.className = 'dependency-item incoming';
                item.innerHTML = `<div>${groupName}</div><div class="dependency-type">${count}개 연결</div>`;
                item.addEventListener('click', () => focusGroup(groupName));
                inList.appendChild(item);
            });

            const outList = document.getElementById('out-dependencies');
            outList.innerHTML = outGroups.size === 0 ? '<div style="color: #8892b0;">없음</div>' : '';
            outGroups.forEach((count, groupName) => {
                const item = document.createElement('div');
                item.className = 'dependency-item outgoing';
                item.innerHTML = `<div>${groupName}</div><div class="dependency-type">${count}개 연결</div>`;
                item.addEventListener('click', () => focusGroup(groupName));
                outList.appendChild(item);
            });
        }

        function updateImpact(node) {
            const impacted = new Set();
            const toVisit = [node.id];
            const visited = new Set();

            let depth = 0;
            while (toVisit.length > 0 && depth < 2) {
                const current = toVisit.shift();
                if (visited.has(current)) continue;
                visited.add(current);

                links.forEach(link => {
                    const sourceId = link.source.id || link.source;
                    const targetId = link.target.id || link.target;
                    
                    if (sourceId === current && !visited.has(targetId)) {
                        impacted.add(targetId);
                        toVisit.push(targetId);
                    }
                });
                depth++;
            }

            const detail = document.getElementById('impact-detail');
            detail.innerHTML = `
                <div>직접 영향: ${links.filter(l => (l.source.id || l.source) === node.id).length}개 API</div>
                <div>간접 영향 (깊이 2): ${impacted.size}개 API</div>
                <div style="margin-top: 8px; color: #8892b0;">
                    이 API를 변경하면 ${impacted.size}개의 다른 API에 영향을 줄 수 있습니다.
                </div>
            `;
        }

        function handleSearch(event) {
            const query = event.target.value.toLowerCase();
            
            if (!query) {
                clearFocus();
                return;
            }

            if (currentView === 'group') {
                const matchingGroup = Array.from(groups.keys()).find(name => 
                    name.toLowerCase().includes(query)
                );
                if (matchingGroup) focusGroup(matchingGroup);
            } else if (currentView === 'detail') {
                const match = nodes.find(n => 
                    n.apiName.toLowerCase().includes(query) ||
                    n.path.toLowerCase().includes(query) ||
                    n.id.toLowerCase().includes(query)
                );
                if (match) focusNode(match);
            }
        }

        function switchView(view) {
            currentView = view;
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.view === view));
            renderGraph();
        }

        function showMatrixDetail(source, target) {
            const deps = links.filter(l => {
                const sourceNode = nodes.find(n => n.id === l.source);
                const targetNode = nodes.find(n => n.id === l.target);
                return sourceNode?.group === source && targetNode?.group === target;
            });

            switchView('detail');
            
            setTimeout(() => {
                const relevantNodes = new Set();
                deps.forEach(dep => {
                    relevantNodes.add(dep.source);
                    relevantNodes.add(dep.target);
                });

                g.selectAll('.node')
                    .classed('highlighted', d => relevantNodes.has(d.id))
                    .classed('dimmed', d => !relevantNodes.has(d.id));

                g.selectAll('.link')
                    .classed('highlighted', d => {
                        const sourceId = d.source.id || d.source;
                        const targetId = d.target.id || d.target;
                        return relevantNodes.has(sourceId) && relevantNodes.has(targetId);
                    })
                    .classed('dimmed', d => {
                        const sourceId = d.source.id || d.source;
                        const targetId = d.target.id || d.target;
                        return !relevantNodes.has(sourceId) || !relevantNodes.has(targetId);
                    });
            }, 500);
        }

        function showGroupTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            const depCount = links.filter(link => {
                const sourceNode = nodes.find(n => n.id === link.source);
                const targetNode = nodes.find(n => n.id === link.target);
                return sourceNode?.group === d.name || targetNode?.group === d.name;
            }).length;
            
            tooltip.innerHTML = `<h4>${d.name}</h4><div class="tooltip-row"><span class="tooltip-label">APIs:</span><span class="tooltip-value">${d.apis.length}</span></div><div class="tooltip-row"><span class="tooltip-label">의존성:</span><span class="tooltip-value">${depCount}</span></div>`;
            tooltip.style.left = event.pageX + 10 + 'px';
            tooltip.style.top = event.pageY + 10 + 'px';
            tooltip.classList.add('show');
        }

        function showNodeTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            const metric = metrics.get(d.id);
            let content = `<h4 style="color: #ffffff;">${d.apiName}</h4><div class="tooltip-row"><span class="tooltip-label">메소드:</span><span class="tooltip-value">${d.method}</span></div><div class="tooltip-row"><span class="tooltip-label">경로:</span><span class="tooltip-value">${d.path}</span></div><div class="tooltip-row"><span class="tooltip-label">그룹:</span><span class="tooltip-value">${d.group}</span></div>`;
            if (metric) {
                content += `<div class="tooltip-row"><span class="tooltip-label">호출:</span><span class="tooltip-value">${metric.calls.toLocaleString()}회</span></div><div class="tooltip-row"><span class="tooltip-label">P95:</span><span class="tooltip-value">${metric.p95}ms</span></div><div class="tooltip-row"><span class="tooltip-label">오류율:</span><span class="tooltip-value">${(metric.errorRate * 100).toFixed(1)}%</span></div>`;
            }
            tooltip.innerHTML = content;
            tooltip.style.left = event.pageX + 10 + 'px';
            tooltip.style.top = event.pageY + 10 + 'px';
            tooltip.classList.add('show');
        }

        function showMatrixTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `<h4>${d.source} → ${d.target}</h4><div class="tooltip-row"><span class="tooltip-label">연결 수:</span><span class="tooltip-value">${d.value}</span></div><div class="tooltip-row"><span class="tooltip-label">총 가중치:</span><span class="tooltip-value">${d.weight}</span></div>`;
            tooltip.style.left = event.pageX + 10 + 'px';
            tooltip.style.top = event.pageY + 10 + 'px';
            tooltip.classList.add('show');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('show');
        }

        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        function updateStats() {
            document.getElementById('stat-groups').textContent = groups.size;
            document.getElementById('stat-apis').textContent = nodes.length;
            document.getElementById('stat-deps').textContent = links.length;
            document.getElementById('stat-cycles').textContent = cycles.length;
        }

        // Zoom controls
        function zoomIn() { svg.transition().duration(300).call(zoom.scaleBy, 1.3); }
        function zoomOut() { svg.transition().duration(300).call(zoom.scaleBy, 0.7); }
        function resetZoom() { svg.transition().duration(300).call(zoom.transform, d3.zoomIdentity); }

        function fitToScreen() {
            const bounds = g.node().getBBox();
            const canvas = document.getElementById('canvas');
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const scale = 0.9 * Math.min(width / bounds.width, height / bounds.height);
            const translate = [width / 2 - scale * (bounds.x + bounds.width / 2), height / 2 - scale * (bounds.y + bounds.height / 2)];
            svg.transition().duration(300).call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
        }

        // Sample data generator
        function loadSampleData() {
            const sampleOpenAPI = {
                openapi: "3.0.0", info: { title: "E-Commerce API", version: "1.0.0" },
                paths: {
                    "/auth/login": { post: { summary: "사용자 로그인", tags: ["auth"] } },
                    "/auth/logout": { post: { summary: "사용자 로그아웃", tags: ["auth"] } },
                    "/auth/register": { post: { summary: "회원 가입", tags: ["auth"] } },
                    "/users": { get: { summary: "사용자 목록 조회", tags: ["user"] }, post: { summary: "사용자 생성", tags: ["user"] } },
                    "/users/{id}": { get: { summary: "사용자 상세 조회", tags: ["user"] }, put: { summary: "사용자 정보 수정", tags: ["user"] }, delete: { summary: "사용자 삭제", tags: ["user"] } },
                    "/products": { get: { summary: "상품 목록 조회", tags: ["product"] }, post: { summary: "상품 등록", tags: ["product"] } },
                    "/products/{id}": { get: { summary: "상품 상세 조회", tags: ["product"] }, put: { summary: "상품 정보 수정", tags: ["product"] }, delete: { summary: "상품 삭제", tags: ["product"] } },
                    "/products/{id}/reviews": { get: { summary: "상품 리뷰 조회", tags: ["product"] }, post: { summary: "리뷰 작성", tags: ["product"] } },
                    "/orders": { get: { summary: "주문 목록 조회", tags: ["order"] }, post: { summary: "주문 생성", tags: ["order"] } },
                    "/orders/{id}": { get: { summary: "주문 상세 조회", tags: ["order"] }, delete: { summary: "주문 취소", tags: ["order"] } },
                    "/cart": { get: { summary: "장바구니 조회", tags: ["order"] }, post: { summary: "장바구니 추가", tags: ["order"] } },
                    "/payments": { post: { summary: "결제 처리", tags: ["payment"] } },
                    "/payments/{id}/refund": { post: { summary: "환불 처리", tags: ["payment"] } },
                    "/admin/dashboard": { get: { summary: "대시보드 데이터", tags: ["report"] } },
                    "/emails/send": { post: { summary: "이메일 발송", tags: ["email"] } }
                }
            };
            const sampleMetrics = [
                { id: "GET_/users", calls: 15000, p95: 250, errorRate: 0.01 },
                { id: "POST_/users", calls: 3000, p95: 450, errorRate: 0.02 },
                { id: "POST_/auth/login", calls: 8000, p95: 320, errorRate: 0.03 },
                { id: "GET_/products", calls: 30000, p95: 200, errorRate: 0.01 },
                { id: "POST_/orders", calls: 5000, p95: 800, errorRate: 0.04 },
                { id: "POST_/payments", calls: 5000, p95: 1200, errorRate: 0.08 },
                { id: "GET_/admin/dashboard", calls: 2000, p95: 2500, errorRate: 0.02 }
            ];
            parseOpenAPI(sampleOpenAPI);
            parseMetrics(sampleMetrics);
            updateStatus('✅ 샘플 데이터 로드 완료');
            renderGraph();
        }
    </script>
</body>
</html>
